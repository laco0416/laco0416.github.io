<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on laco&#39;s blog</title>
    <link>http://blog.lacolaco.net/post/</link>
    <description>Recent content in Posts on laco&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Thu, 11 Aug 2016 12:00:00 +0900</lastBuildDate>
    <atom:link href="http://blog.lacolaco.net/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dynamic Component Creation in Angular 2 RC.5</title>
      <link>http://blog.lacolaco.net/post/dynamic-component-creation-in-angular-2-rc-5/</link>
      <pubDate>Thu, 11 Aug 2016 12:00:00 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/dynamic-component-creation-in-angular-2-rc-5/</guid>
      <description>

&lt;p&gt;Few months ago, I wrote an article, &lt;a href=&#34;http://blog.lacolaco.net/post/dynamic-component-creation-in-angular-2/&#34;&gt;Dynamic Component Creation in Angular 2&lt;/a&gt;.
It said how to load a HTML template with using &lt;em&gt;dynamic component creation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, Angular 2 RC.5 has released! Some APIs were deprecated and some introduced.
Let&amp;rsquo;s revise my &lt;em&gt;dynamic component creation&lt;/em&gt; in latest Angular 2.&lt;/p&gt;

&lt;p&gt;Angular version: 2.0.0-rc.5&lt;/p&gt;

&lt;h2 id=&#34;componentoutlet-directive&#34;&gt;&lt;code&gt;ComponentOutlet&lt;/code&gt; directive&lt;/h2&gt;

&lt;p&gt;Previously, I declared &lt;code&gt;DynamicHTMLOutlet&lt;/code&gt;;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({
    selector: &#39;dynamic-html-outlet&#39;,
})
export class DynamicHTMLOutlet {
  @Input() src: string;
  
  constructor(private vcRef: ViewContainerRef, private resolver: ComponentResolver) {
  }
  
  ngOnChanges() {
    if (!this.src) return;
    
    const metadata = new ComponentMetadata({
        selector: &#39;dynamic-html&#39;,
        template: this.src,
    });
    createComponentFactory(this.resolver, metadata)
      .then(factory =&amp;gt; {
        const injector = ReflectiveInjector.fromResolvedProviders([], this.vcRef.parentInjector);
        this.vcRef.createComponent(factory, 0, injector, []);
      });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My new idea is &lt;code&gt;ComponentOutlet&lt;/code&gt;, it has own template, selector and &lt;strong&gt;context&lt;/strong&gt;.
By &lt;strong&gt;context&lt;/strong&gt; passing, we can use data-binding and event-handling in the dynamic template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({
  selector: &#39;[componentOutlet]&#39;,
})
export class ComponentOutlet {
  @Input(&#39;componentOutlet&#39;) private template: string;
  @Input(&#39;componentOutletSelector&#39;) private selector: string;
  @Input(&#39;componentOutletContext&#39;) private context: Object;

  private _createDynamicComponent() {
    this.context = this.context || {};

    const metadata = new ComponentMetadata({
      selector: this.selector,
      template: this.template,
    });

    const cmpClass = class _ { };
    cmpClass.prototype = this.context;
    return Component(metadata)(cmpClass);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it&amp;rsquo;s used with templating syntax (&lt;code&gt;*&lt;/code&gt;-prefix) like &lt;code&gt;*ngIf&lt;/code&gt;.
Templating syntax can turn the element into the template which doesn&amp;rsquo;t appear in the DOM.
So, we can replace an element has &lt;code&gt;componentOutlet&lt;/code&gt; with the dynamic component.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({
    selector: &#39;my-app&#39;,
    template: `
    &amp;lt;div *componentOutlet=&amp;quot;html; context:self; selector:&#39;my-dynamic-component&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    `,
})
export class App {
  self = this; // copy of context
  html = `
  &amp;lt;div&amp;gt;
    &amp;lt;button (click)=&amp;quot;self.showAlert(&#39;dynamic component&#39;)&amp;quot;&amp;gt;Click&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;`;
  
  setMessage(message: string) {
    alert(message);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It turns into like below;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;my-app&amp;gt;
    &amp;lt;my-dynamic-component&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;button&amp;gt;Click&amp;lt;button&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;my-dynamic-component&amp;gt;
&amp;lt;/my-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is what I really wanted. don&amp;rsquo;t you?&lt;/p&gt;

&lt;h2 id=&#34;use-compiler&#34;&gt;Use &lt;code&gt;Compiler&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;In RC.5, &lt;code&gt;ComponentResolver&lt;/code&gt; is deprecated. Instead, We can use &lt;code&gt;Compiler&lt;/code&gt; API to create &lt;code&gt;ComponentFactory&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;this.resolver.resolveComponent(this._createDynamicComponent())
    .then(factory =&amp;gt; {
        ...
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;this.compiler.compileComponentAsync(this._createDynamicComponent())
    .then(factory =&amp;gt; {
        ...
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Compiler&lt;/code&gt; belongs to the application module.
So the compiler can use all directives and pipes which is in &lt;code&gt;declarations&lt;/code&gt; of the module.&lt;/p&gt;

&lt;p&gt;At the final, &lt;code&gt;ComponentOutlet&lt;/code&gt; code is following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({
  selector: &#39;[componentOutlet]&#39;,
})
export class ComponentOutlet {
  @Input(&#39;componentOutlet&#39;) private template: string;
  @Input(&#39;componentOutletSelector&#39;) private selector: string;
  @Input(&#39;componentOutletContext&#39;) private context: Object;

  constructor(private vcRef: ViewContainerRef, private compiler: Compiler) { }

  private _createDynamicComponent() {
    this.context = this.context || {};

    const metadata = new ComponentMetadata({
      selector: this.selector,
      template: this.template,
    });

    const cmpClass = class _ { };
    cmpClass.prototype = this.context;
    return Component(metadata)(cmpClass);
  }

  ngOnChanges() {
    if (!this.template) return;
    this.compiler.compileComponentAsync(this._createDynamicComponent())
      .then(factory =&amp;gt; {
        const injector = ReflectiveInjector.fromResolvedProviders([], this.vcRef.parentInjector);
        this.vcRef.clear();
        this.vcRef.createComponent(factory, 0, injector);
      });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s use the outlet.&lt;/p&gt;

&lt;iframe src=&#34;http://embed.plnkr.co/1dlbF4/&#34; width=&#34;100%&#34; height=&#34;300&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
    selector: &#39;my-app&#39;,
    template: `
        &amp;lt;p&amp;gt;{{message}}&amp;lt;/p&amp;gt;
        &amp;lt;div *componentOutlet=&amp;quot;html; context:self; selector:&#39;my-dynamic-component&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    `,
})
export class App {
  message = &#39;static component&#39;;
  self = this; // copy of context
  html = `
  &amp;lt;div&amp;gt;
    &amp;lt;button (click)=&amp;quot;self.setMessage(&#39;dynamic component&#39;)&amp;quot;&amp;gt;Click&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;`;
  
  setMessage(message: string) {
    this.message = message;
  }
}

@NgModule({
  imports: [BrowserModule],
  declarations: [App, ComponentOutlet],
  bootstrap: [App]
})
export class AppModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ComponentOutlet&lt;/code&gt; with &lt;code&gt;*&lt;/code&gt;-prefix syntax&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NgModule&lt;/code&gt; and &lt;code&gt;Compiler&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to use my &lt;code&gt;ComponentOutlet&lt;/code&gt;, you can install &lt;code&gt;angular2-component-outlet&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/laco0416/angular2-component-outlet&#34; target=&#34;_blank&#34;&gt;laco0416/angular2-component-outlet: Angular2 dynamic component outlet&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save angular2-component-outlet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please give me feedback!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to Use Angular 2 Nightly Builds</title>
      <link>http://blog.lacolaco.net/post/how-to-use-angular-2-nightly-builds/</link>
      <pubDate>Fri, 05 Aug 2016 22:04:30 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/how-to-use-angular-2-nightly-builds/</guid>
      <description>

&lt;p&gt;This post explains how to use nightly-builds of Angular 2.&lt;/p&gt;

&lt;p&gt;Angular 2 consists of some modules. Each module has own package and its version.
And there are nightly-builds packages of these.&lt;/p&gt;

&lt;h2 id=&#34;nightly-builds&#34;&gt;Nightly Builds&lt;/h2&gt;

&lt;p&gt;Nightly-builds has its own repository.
For example, &lt;code&gt;@angular/core&lt;/code&gt; repo corresponds to &lt;code&gt;angular/core-builds&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/angular/core-builds&#34; target=&#34;_blank&#34;&gt;angular/core-builds: @angular/core build artifacts&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Every &lt;code&gt;@angular&lt;/code&gt; packages has corresponding &lt;code&gt;-builds&lt;/code&gt; repo.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angular/core-builds&#34; target=&#34;_blank&#34;&gt;angular/core-builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angular/common-builds&#34; target=&#34;_blank&#34;&gt;angular/common-builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angular/compiler-builds&#34; target=&#34;_blank&#34;&gt;angular/compiler-builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angular/platform-browser-builds&#34; target=&#34;_blank&#34;&gt;angular/platform-browser-builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;and more&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These repositories are updated when the main repo&amp;rsquo;s master is committed.
So these help us if you want to &lt;strong&gt;use new features&lt;/strong&gt; or &lt;strong&gt;avoid bugs&lt;/strong&gt; which not released yet.&lt;/p&gt;

&lt;h2 id=&#34;how-to-use&#34;&gt;How to use&lt;/h2&gt;

&lt;p&gt;Each repo has its &lt;code&gt;package.json&lt;/code&gt;. so we can install these via &lt;code&gt;npm install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save angular/core-builds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or &lt;code&gt;dependencies&lt;/code&gt; field in &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;dependencies&amp;quot;: {
        &amp;quot;@angular/core&amp;quot;: &amp;quot;angular/core-builds&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;npm supports dependencies from GitHub. My dependencies are below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;@angular/common&amp;quot;: &amp;quot;angular/common-builds&amp;quot;,
    &amp;quot;@angular/compiler&amp;quot;: &amp;quot;angular/compiler-builds&amp;quot;,
    &amp;quot;@angular/compiler-cli&amp;quot;: &amp;quot;angular/compiler-cli-builds&amp;quot;,
    &amp;quot;@angular/core&amp;quot;: &amp;quot;angular/core-builds&amp;quot;,
    &amp;quot;@angular/forms&amp;quot;: &amp;quot;angular/forms-builds&amp;quot;,
    &amp;quot;@angular/platform-browser&amp;quot;: &amp;quot;angular/platform-browser-builds&amp;quot;,
    &amp;quot;@angular/platform-browser-dynamic&amp;quot;: &amp;quot;angular/platform-browser-dynamic-builds&amp;quot;,
    &amp;quot;@angular/platform-server&amp;quot;: &amp;quot;angular/platform-server-builds&amp;quot;,
    &amp;quot;@angular/router&amp;quot;: &amp;quot;angular/router-builds&amp;quot;,
    &amp;quot;core-js&amp;quot;: &amp;quot;^2.4.0&amp;quot;,
    &amp;quot;rxjs&amp;quot;: &amp;quot;5.0.0-beta.6&amp;quot;,
    &amp;quot;zone.js&amp;quot;: &amp;quot;^0.6.6&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;All Angular 2 modules have its own nightly-builds repo&lt;/li&gt;
&lt;li&gt;Nightly-builds are synchronized with &lt;code&gt;angular/angular&lt;/code&gt; master&lt;/li&gt;
&lt;li&gt;We can use these via npm GitHub dependencies&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Angular 2 Router v3.0.0-alpha.3を触ってみた</title>
      <link>http://blog.lacolaco.net/post/angular-2-router-v3-alpha-3/</link>
      <pubDate>Fri, 10 Jun 2016 20:18:51 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/angular-2-router-v3-alpha-3/</guid>
      <description>

&lt;p&gt;今日リリースされたAngular 2 Router v3.0.0-alpha.3を触ってみたうえでの注意点や感想を書いておきます。&lt;/p&gt;

&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -S -E @angular/router@3.0.0-alpha.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すでにlatestも3.0.0-alpha.3になっているんですが、とりあえずバージョン固定の &lt;code&gt;-E&lt;/code&gt; にしておくのをオススメします&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;typings&lt;/code&gt; と &lt;code&gt;typescript@next&lt;/code&gt; が必要です。 前者は &lt;code&gt;postinstall&lt;/code&gt; で要求されるのでインストール時にだけ必要で、後者はビルドに必要です。&lt;/p&gt;

&lt;h3 id=&#34;router-deprecated-からの変更点&#34;&gt;&lt;code&gt;@router-deprecated&lt;/code&gt; からの変更点&lt;/h3&gt;

&lt;p&gt;ほぼすべてが変わったので書き換える箇所は多かったですが、書き換え方は単純だったのでさほど苦しみはなかったです&lt;/p&gt;

&lt;h4 id=&#34;ルート定義&#34;&gt;ルート定義&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteConfig&lt;/code&gt; は無くなった&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouterConfig&lt;/code&gt; 型でルートを記述する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; は無くなった&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useAsDefault&lt;/code&gt; は &lt;code&gt;index&lt;/code&gt; になった&lt;/li&gt;
&lt;li&gt;入れ子のルートは &lt;code&gt;children&lt;/code&gt; を使う&lt;/li&gt;
&lt;li&gt;ワイルドカードは &lt;code&gt;**&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export const ROUTES: RouterConfig = [
    { path: &#39;/home&#39;, component: HomeCmp, index: true },
    { path: &#39;/chat&#39;, component: ChatCmp},
    { 
        path: &#39;/team/:id&#39;, 
        component: TeamCmp,
        children: [
            { path: &#39;/details&#39;, component: DetailsCmp }
        ] 
    },
    { path: &#39;**&#39;, redirectTo: &#39;/home&#39; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bootstrap時に &lt;code&gt;provideRouter&lt;/code&gt; を使う&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;RouterOutlet&lt;/code&gt; の使い方は今までと変わりません。ルートのコンポーネントと、&lt;code&gt;children&lt;/code&gt;を持つコンポーネントは&lt;code&gt;&amp;lt;router-outlet&amp;gt;&lt;/code&gt;を持つ必要があります&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {ROUTES} from &#39;./app.routes&#39;;

bootstrap(App, [
    provideRouter(ROUTES);
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまでと違い、ルート定義はコンポーネントの持ち物ではなく、アプリケーションの持ち物になりました。
&lt;code&gt;@RouteConfig&lt;/code&gt; で書いていたルート定義をカットアンドペーストでガシガシ集めていく作業です。&lt;/p&gt;

&lt;h4 id=&#34;ナビゲーション&#34;&gt;ナビゲーション&lt;/h4&gt;

&lt;p&gt;ルート定義から &lt;code&gt;name&lt;/code&gt; がなくなったので、必然的にURLのパスでナビゲーションを行います。
セグメントを配列形式で表現するのはそのままです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;this.router.navigate([&#39;/team&#39;, this.teamId, &#39;user&#39;, this.userName]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RouterLinkを使うと次のようになります。これもほとんど変わってないですね&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a [routerLink]=&amp;quot;[&#39;/team&#39;, teamId, &#39;user&#39;, userName]&amp;quot;&amp;gt;{{ userName }}&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相対パスでの移動も可能ですが、今のところは相対パスの解決をするために &lt;code&gt;ActivatedRoute&lt;/code&gt; を使わないといけません&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class TeamCmp {

    constructor(private router: Router, private route: ActivatedRoute) {
    }

    navigateToMember(name: string) {
        this.router.navigate([&#39;./user&#39;, name], { relativeTo: this.route });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すこし冗長ですが、&lt;code&gt;relativeTo&lt;/code&gt; に渡したRoute(つまり &lt;code&gt;/team/:id&lt;/code&gt;) を起点にパスの解決をしてくれます。
&lt;code&gt;ActivatedRoute&lt;/code&gt; はこのあとにも何度も出てくるRouter v3の重要キャラクターです。&lt;/p&gt;

&lt;p&gt;クエリパラメータを付けてナビゲートしたいときは次のようにします&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const params = { foo: &#39;bar&#39; };

this.router.navigate([&#39;/with-query-params&#39;], { queryParams: params });
// =&amp;gt; /with-query-params?foo=bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フラグメント( &lt;code&gt;#section&lt;/code&gt; 的なやつ) も同様です&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;this.router.navigate([&#39;/with-fragment&#39;], { fragment: &#39;sectionA&#39; });
// =&amp;gt; /with-fragment#sectionA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リンクパラメータの中にオブジェクトを挿入すると、そのセグメントでのマトリクスパラメータになります。
v1やv2ではこれがクエリパラメータと混ざってしまうバグなどありましたが、完全に別物になったので使いやすくなりました&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;this.router.navigate([&#39;/foo&#39;, {extra: true}, &#39;bar&#39;]);
// =&amp;gt; /foo;extra=true/bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;パラメータの受け取り&#34;&gt;パラメータの受け取り&lt;/h4&gt;

&lt;p&gt;コンポーネントが現在のルートからデータを取得するためには &lt;code&gt;ActivatedRoute&lt;/code&gt; を使います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/team/:id&lt;/code&gt; のようなURLパラメータは &lt;code&gt;ActivatedRoute#params&lt;/code&gt; から取得できます。
これはObservableになっていて、&lt;code&gt;.subscribe&lt;/code&gt;することで非同期的にパラメータを取得できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class TeamCmp {
    id: string;

    constructor(private router: Router, private route: ActivatedRoute) {
    }

    ngOnInit() {
        this.route.params.subscribe(params =&amp;gt; {
            this.id = params[&#39;id&#39;];
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までは確実にルーターから読み込まれたときにパラメータを取得するには &lt;code&gt;routerOnActivate&lt;/code&gt; で &lt;code&gt;ComponentInstruction&lt;/code&gt; を受け取る必要がありましたが、
&lt;code&gt;ActivatedRoute&lt;/code&gt;がその役目を負ってくれるので、コンポーネントの初期化は&lt;code&gt;ngOnInit&lt;/code&gt;にまとめることができます。&lt;/p&gt;

&lt;p&gt;上位のルートのパラメータを取得するには少し複雑になります。例えばユーザー詳細からチームのIDを手に入れるには次のように書きます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class UserCmp {
    teamId: string;
    name: string;

    constructor(private router: Router, private route: ActivatedRoute) {
    }

    ngOnInit() {
        const teamRoute = this.router.routerState.parent(this.route);
        this.teamRoute.params.subscribe(params =&amp;gt; {
            this.teamId = params[&#39;id&#39;];
        });
        this.route.params.subscribe(params =&amp;gt; {
            this.name = params[&#39;name&#39;];
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリパラメータやフラグメントも同様にObservableで手に入ります。これらはどのルートにいるかに寄らないので、&lt;code&gt;Router&lt;/code&gt;だけで取得できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const currentState = this.router.routerState;
currentState.queryParams.subscribe(params =&amp;gt; {
    // params: {[key:string]: string}
});
currentState.fragment.subscribe(fragment =&amp;gt; {
    // fragment: string
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;その他&#34;&gt;その他&lt;/h4&gt;

&lt;p&gt;ルートの状態の変更は &lt;code&gt;Router#events&lt;/code&gt; からObservableで取得できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;this.router.events.subscribe(ev =&amp;gt; {
    console.log(ev);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CanActivate&lt;/code&gt; や &lt;code&gt;CanDeactivate&lt;/code&gt; はまだ試せていません。 &lt;code&gt;Guard&lt;/code&gt; という仕組みもあって強力な遷移制御ができるので、後日試します。
公式のサンプルを見るとCanDeactivateとGuardの実例があるので参考になると思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://plnkr.co/edit/ER0tf8fpGHZiuVWB7Q07?p=preview&#34; target=&#34;_blank&#34;&gt;http://plnkr.co/edit/ER0tf8fpGHZiuVWB7Q07?p=preview&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;注意点&#34;&gt;注意点&lt;/h3&gt;

&lt;h4 id=&#34;typescript-1-9を要求する&#34;&gt;TypeScript 1.9を要求する&lt;/h4&gt;

&lt;p&gt;配布されているパッケージが含んでいるd.tsファイルに&lt;code&gt;readonly&lt;/code&gt;が含まれているので、TypeScript 1.9以降でないとビルドできません。&lt;/p&gt;

&lt;h4 id=&#34;いくつかのバグ&#34;&gt;いくつかのバグ&lt;/h4&gt;

&lt;p&gt;次の2つのバグを踏みました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angular/vladivostok/issues/26&#34; target=&#34;_blank&#34;&gt;Bug: CanDeactivate doesn&amp;rsquo;t run from child route · Issue #26 · angular/vladivostok&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ネストされたルートから別のネストの中のルートに移動しようとすると、&lt;code&gt;CanDeactivate&lt;/code&gt;の解決順序のバグでエラーが発生します。
ワークアラウンドとして、直接ナビゲートするのではなく、上位のルートを踏んでから段階的に遷移することで回避できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// from menu1/item1
this.router.navigate([&#39;/&#39;])
    .then(() =&amp;gt; {
        this.router.navigate([&#39;/menu2/item1&#39;]);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angular/vladivostok/issues/16&#34; target=&#34;_blank&#34;&gt;Bug: URL is not updated to index route path · Issue #16 · angular/vladivostok&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;index&lt;/code&gt; オプションを使って設定したルートが使われるときに、本来のURLに書き換えられないバグです。
&lt;code&gt;/home&lt;/code&gt; をindexにしたときに、 &lt;code&gt;/&lt;/code&gt; に来たらHomeCmpが表示されますが、URLは&lt;code&gt;/&lt;/code&gt;のままになってしまいます。&lt;/p&gt;

&lt;p&gt;これは今のところどうしようもないので、無理やり解決したければURLの変更を監視してlocationを書き換えないといけません&lt;/p&gt;

&lt;h3 id=&#34;所感&#34;&gt;所感&lt;/h3&gt;

&lt;p&gt;Router v1やv2とはルート定義の書き方が大きく変わりましたが、そこは本質ではなくて、Observableの積極的な活用こそがv3の肝です。
Observableによって手に入る最新の状態を使えば良いので、&lt;code&gt;RouteParams&lt;/code&gt;や&lt;code&gt;ComponentInstruction&lt;/code&gt;で混乱することはありません。
ミュータブルな値を扱わずに済むというのが、v3が素晴らしいルータである理由のひとつです。&lt;/p&gt;

&lt;p&gt;とはいえまだalphaバージョンでバグもあり完全ではないですが、すぐにBeta Routerから移行できるだけのものは揃っているようです。
ルート定義が増えるほど手間も増えるので、Beta Routerを使っている場合はなるべく早く書き換えたほうがよいでしょう。
これから開発する場合はv3で決まりです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Component Creation in Angular 2</title>
      <link>http://blog.lacolaco.net/post/dynamic-component-creation-in-angular-2/</link>
      <pubDate>Wed, 25 May 2016 13:00:00 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/dynamic-component-creation-in-angular-2/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;
Revised in &lt;a href=&#34;http://blog.lacolaco.net/post/dynamic-component-creation-in-angular-2-rc-5/&#34;&gt;Dynamic Component Creation in Angular 2 RC.5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since Angular 2, &lt;code&gt;$compile&lt;/code&gt; was dropped.
There are no ways to insert HTML fragments into the component view except using &lt;code&gt;innerHTML&lt;/code&gt;.
But if we could create a component and load it&amp;hellip;? Yes, we can do it!
This post will explain about &lt;strong&gt;dynamic HTML projection&lt;/strong&gt; in Angular 2 with dynamic component creation.&lt;/p&gt;

&lt;p&gt;Angular version: 2.0.0-rc.1&lt;/p&gt;

&lt;h2 id=&#34;component-as-a-function&#34;&gt;&lt;code&gt;Component&lt;/code&gt; as a function&lt;/h2&gt;

&lt;p&gt;We usually use a decorator, &lt;code&gt;@Component&lt;/code&gt;, to create a component class like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
    selector: &#39;static-component&#39;,
    template: `&amp;lt;p&amp;gt;Static Component&amp;lt;/p&amp;gt;`
})
class StaticComponent {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, above component is almost equivalent to the next:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class DynamicComponent {
}

const dynamicComponent = Component({
    selector: &#39;dynamic-component&#39;,
    template: `&amp;lt;p&amp;gt;Dynamic Component&amp;lt;/p&amp;gt;`
})(DynamicComponent);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Decorator isn&amp;rsquo;t a magic. It&amp;rsquo;s just function-calling.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;dynamic-component-loading&#34;&gt;Dynamic Component Loading&lt;/h2&gt;

&lt;p&gt;We can already use &lt;code&gt;ViewContainerRef&lt;/code&gt; and &lt;code&gt;ComponentResolver&lt;/code&gt; to load components into the host component dynamically.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/core/index/ViewContainerRef-class.html&#34; target=&#34;_blank&#34;&gt;ViewContainerRef - ts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/core/index/ComponentResolver-class.html&#34; target=&#34;_blank&#34;&gt;ComponentResolver - ts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;viewcontainerref&#34;&gt;ViewContainerRef&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ViewContainerRef&lt;/code&gt; is a &lt;strong&gt;container&lt;/strong&gt; where one or more views can be attached.
It&amp;rsquo;s used in many places; &lt;code&gt;NgIf&lt;/code&gt;, &lt;code&gt;NgFor&lt;/code&gt;, &lt;code&gt;RouterOutlet&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Creation types by &lt;code&gt;ViewContainerRef&lt;/code&gt; are two pattern.
One is &lt;strong&gt;loading into next location&lt;/strong&gt;. A component is loaded into the next location of the container.&lt;/p&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;container-directive&amp;gt;&amp;lt;/container-directive&amp;gt;
&amp;lt;loaded-directive&amp;gt;&amp;lt;/loaded-directive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another is &lt;strong&gt;loading as embedded view&lt;/strong&gt;. It needs &lt;code&gt;TemplateRef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;container-directive&amp;gt;
    &amp;lt;loaded-directive&amp;gt;&amp;lt;/loaded-directive&amp;gt;
&amp;lt;/container-directive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;componentresolver&#34;&gt;ComponentResolver&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ComponentResolver&lt;/code&gt; is a service to create &lt;code&gt;ComponentFactory&lt;/code&gt; from a component type.
All components are loaded into the view by &lt;code&gt;ComponentFactory&lt;/code&gt;.
&lt;code&gt;ComponentResolver&lt;/code&gt; has a method, &lt;code&gt;resolveComponent&lt;/code&gt;, which return a promise of &lt;code&gt;ComponentFactory&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;dynamic-component-factory&#34;&gt;Dynamic Component Factory&lt;/h2&gt;

&lt;p&gt;So, we can create any components in dynamically by using above features.
Let&amp;rsquo;s look at the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function createComponentFactory(resolver: ComponentResolver, metadata: ComponentMetadata): Promise&amp;lt;ComponentFactory&amp;lt;any&amp;gt;&amp;gt; {
    const cmpClass = class DynamicComponent {};
    const decoratedCmp = Component(metadata)(cmpClass);
    return resolver.resolveComponent(decoratedCmp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createComponentFactory&lt;/code&gt; returns a promise of &lt;code&gt;ComponentFactory&lt;/code&gt; created dynamically. It&amp;rsquo;s very simple.&lt;/p&gt;

&lt;p&gt;Next, use the function at new &lt;code&gt;DynamicHTMLOutlet&lt;/code&gt; directive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({
    selector: &#39;dynamic-html-outlet&#39;,
})
export class DynamicHTMLOutlet {
  @Input() src: string;
  
  constructor(private vcRef: ViewContainerRef, private resolver: ComponentResolver) {
  }
  
  ngOnChanges() {
    if (!this.src) return;
    
    const metadata = new ComponentMetadata({
        selector: &#39;dynamic-html&#39;,
        template: this.src,
    });
    createComponentFactory(this.resolver, metadata)
      .then(factory =&amp;gt; {
        const injector = ReflectiveInjector.fromResolvedProviders([], this.vcRef.parentInjector);
        this.vcRef.createComponent(factory, 0, injector, []);
      });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last, let&amp;rsquo;s use the outlet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
    selector: &#39;my-app&#39;,
    template: `
        &amp;lt;dynamic-html-outlet [src]=&amp;quot;html&amp;quot;&amp;gt;&amp;lt;/dynamic-html-outlet&amp;gt;
    `,
    directives: [DynamicHTMLOutlet]
})
export class MyApp {
    html = `&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Dynamic HTML Fragment&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plunker is &lt;a href=&#34;http://plnkr.co/edit/HCz7Kc&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Decorators are just function&lt;/li&gt;
&lt;li&gt;You can create a component by using &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;ComponentResolver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can load a component by using &lt;code&gt;ViewContainerRef&lt;/code&gt; and &lt;code&gt;ComponentFactory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Angular 2 New Router Overview</title>
      <link>http://blog.lacolaco.net/post/angular-2-alt-router-overview/</link>
      <pubDate>Sat, 30 Apr 2016 20:24:46 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/angular-2-alt-router-overview/</guid>
      <description>

&lt;p&gt;EDIT(2016-05-02):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add a section for wildcard route&lt;/li&gt;
&lt;li&gt;Update from &lt;code&gt;Tree&amp;lt;RouteSegment&amp;gt;&lt;/code&gt; to &lt;code&gt;RouteTree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add a part of &lt;code&gt;router-link-active&lt;/code&gt; class&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Angular core team (mainly &lt;a href=&#34;https://twitter.com/victorsavkin&#34; target=&#34;_blank&#34;&gt;@victorsavkin&lt;/a&gt;) is developing new router package; &lt;strong&gt;angular2/alt_router&lt;/strong&gt;.
It&amp;rsquo;s still experimental but its APIs are easier and more intuitive than &lt;em&gt;old&lt;/em&gt; angular2/router.
Let&amp;rsquo;s figure out overview of next generation router!&lt;/p&gt;

&lt;p&gt;CAUTION: &lt;strong&gt;Every contents in this article can be always deprecated.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;routerconfig-to-routes&#34;&gt;&lt;code&gt;@RouterConfig&lt;/code&gt; to &lt;code&gt;@Routes&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;In order to declare a setting of routing, we have to use &lt;code&gt;Routes&lt;/code&gt; decorator like old &lt;code&gt;RouteConfig&lt;/code&gt;.
But its element is so simple, which has only two properties; &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;component&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class UserComponent {
}

@Component({...})
@Routes([
    new Route({path: &amp;quot;/user/:name&amp;quot;, component: UserComponent })
])
class TeamComponent {
}

@Component({...})
@Routes([
    {path: &amp;quot;/team/:id&amp;quot;, component: TeamComponent}
])
class AppRootComponent {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;strong&gt;wildcards&lt;/strong&gt; are supported.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({...})
@Routes([
    {path: &amp;quot;/team/:id&amp;quot;, component: TeamComponent},
    {path: &amp;quot;/*&amp;quot;, component: DefaultComponent}
])
class AppRootComponent {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point: &lt;strong&gt;New route config no longer has a &lt;em&gt;name&lt;/em&gt; property.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;router-outlet-component&#34;&gt;&lt;code&gt;&amp;lt;router-outlet&amp;gt;&lt;/code&gt; component&lt;/h2&gt;

&lt;p&gt;We can use &lt;code&gt;&amp;lt;router-outlet&amp;gt;&lt;/code&gt; as well as old router.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
    ...
    template: `
    &amp;lt;!-- default outlet --&amp;gt;    
    &amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;
    &amp;lt;!-- aux outlet --&amp;gt;    
    &amp;lt;router-outlet name=&amp;quot;aux&amp;quot;&amp;gt;&amp;lt;/router-outlet&amp;gt;
    `,
    directives: [ROUTER_DIRECTIVES]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;routerlink-directive&#34;&gt;&lt;code&gt;routerLink&lt;/code&gt; directive&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;routerLink&lt;/code&gt; directive is still alive, but it takes an array of &lt;strong&gt;url segments&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a [routerLink]=&amp;quot;[&#39;/team&#39;, 33, &#39;user&#39;, &#39;victor&#39;]&amp;quot;&amp;gt;Victor Savkin&amp;lt;/a&amp;gt;

&amp;lt;!--equivalent--&amp;gt;
&amp;lt;a [routerLink]=&amp;quot;[&#39;/team/33/user/victor&#39;]&amp;quot;&amp;gt;Victor Savkin&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the link matches current route, &lt;code&gt;router-link-active&lt;/code&gt; class is applied.&lt;/p&gt;

&lt;h2 id=&#34;router-class&#34;&gt;&lt;code&gt;Router&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;New router has &lt;code&gt;Router&lt;/code&gt; class, which is almost similar to old &lt;code&gt;Router&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class SomeComponent {
    constructor(private router: Router) {}
    
    doNavigationByUrl() {
        this.router.navigateByUrl(&amp;quot;/some/path&amp;quot;);
    }
    
    doNavigationByArray() {
        this.router.navigate([&amp;quot;/some/path&amp;quot;]);
    }
    
    listenUrlChangeEvent() {
        this.router.changes.subscribe(() =&amp;gt; {
            // `changes` gives no arguments.
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lifecycle-methods&#34;&gt;Lifecycle methods&lt;/h2&gt;

&lt;p&gt;New router has only two lifecycle methods yet, &lt;code&gt;OnActivate&lt;/code&gt; and &lt;code&gt;CanDeactivate&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;onactivate&#34;&gt;&lt;code&gt;OnActivate&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;New &lt;code&gt;OnActivate&lt;/code&gt; interface has a &lt;code&gt;routerOnActivate&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class SomeComponent implements OnActivate {
    routerOnActivate(
        curr: RouteSegment, 
        prev?: RouteSegment, 
        currTree?: RouteTree, 
        prevTree?: RouteTree
    ): void {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments of &lt;code&gt;routerOnActivate&lt;/code&gt; are completely changed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;curr: RouteSegment&lt;/strong&gt;: Current (in activating) segment&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prev?: RouteSegment&lt;/strong&gt;: Previous segment&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;currTree?: RouteTree;&lt;/strong&gt;: A segment tree composing current route&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prevTree?: RouteTree;&lt;/strong&gt;: A previous segment tree&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;routesegment-new-api-like-componentinstruction&#34;&gt;&lt;code&gt;RouteSegment&lt;/code&gt;: new API like &lt;code&gt;ComponentInstruction&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;RouteSegment&lt;/code&gt; represents an information of the component transition.
It&amp;rsquo;s similar to &lt;code&gt;ComponentInstruction&lt;/code&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;ComponentInstruction&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;RouteSegment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;inst.componentInstruction&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;segment.component&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;inst.params&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;segment.parameters&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;inst.urlParams&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;segment.parameters&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;inst.params[key]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;segment.getParam(key)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;inst.urlPath&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;segment.stringifiedUrlSegments()&lt;/code&gt; or &lt;code&gt;Location.path()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;segment.outlet&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;inst.routeName&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;inst.routeData&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can use &lt;code&gt;getParam()&lt;/code&gt; to get route parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({...})
class TeamComponent {
    id: string;
    
    routerOnActivate(curr: RouteSegment) {
        this.id = curr.getParam(&amp;quot;id&amp;quot;);
    }
}

@Component({...})
@Routes([
    {path: &amp;quot;/team/:id&amp;quot;, component: TeamComponent}
])
class AppRootComponent {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;routetree-tree-structure-of-routes&#34;&gt;&lt;code&gt;RouteTree&lt;/code&gt;: Tree structure of routes&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;RouteSegment&lt;/code&gt; has the information of &lt;em&gt;single&lt;/em&gt; route transition.
it means the segment doesn&amp;rsquo;t have any parameters of parent routes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class UserComponent {
    
    routerOnActivate(curr: RouteSegment) {
        let name = curr.getParam(&amp;quot;name&amp;quot;); // OK!
        let teamId = curr.getParam(&amp;quot;id&amp;quot;); // NG!
    }
}

@Component({...})
@Routes([
    new Route({path: &amp;quot;/user/:name&amp;quot;, component: UserComponent })
])
class TeamComponent {
}

@Component({...})
@Routes([
    {path: &amp;quot;/team/:id&amp;quot;, component: TeamComponent}
])
class AppRootComponent {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, &lt;code&gt;currTree&lt;/code&gt; allows us to access &lt;strong&gt;parent segment&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({...})
class UserComponent {
    
    routerOnActivate(curr: RouteSegment, prev, currTree: RouteTree) {
        let name = curr.getParam(&amp;quot;name&amp;quot;); // OK!
        let teamSegment = currTree.parent(curr); // &amp;quot;parent of curr&amp;quot;
        let teamId = teamSegment.getParam(&amp;quot;id&amp;quot;); // OK!
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, the tree has &lt;strong&gt;child segment&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({...})
class TeamComponent {    
    routerOnActivate(curr: RouteSegment, prev, currTree: RouteTree) {
        let id = curr.getParam(&amp;quot;id&amp;quot;);
        let userSegment = currTree.firstChild(curr);
        let currentUserName = userSegment.getParam(&amp;quot;name&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point: New API; &lt;code&gt;RouteSegment&lt;/code&gt; and &lt;code&gt;RouteTree&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;candeactivate&#34;&gt;&lt;code&gt;CanDeactivate&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;CanDeactivate&lt;/code&gt; defines route lifecycle method &lt;code&gt;routerCanDeactivate&lt;/code&gt; same as old router&amp;rsquo;s one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({...})
class SomeComponent implements CanDeactivate {
  constructor(private logService: LogService) {}
  
  routerCanDeactivate(currTree: RouteTree, furuteTree: RouteTree): Promise&amp;lt;boolean&amp;gt; {
    return Promise.resolve(confirm(&#39;Are you sure you want to leave?&#39;));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;router-outlet&amp;gt;&lt;/code&gt; and &lt;code&gt;routerLink&lt;/code&gt; are alive!&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteConfig&lt;/code&gt; turns into &lt;code&gt;Routes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Route definition no longer has own name&lt;/li&gt;
&lt;li&gt;New API: &lt;code&gt;RouteSegment&lt;/code&gt; and &lt;code&gt;RouteTree&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;New router is nice but you should be careful.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Don&amp;rsquo;t forget that&amp;rsquo;s experimental!&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Broadcasting events in Angular 2</title>
      <link>http://blog.lacolaco.net/post/event-broadcasting-in-angular-2/</link>
      <pubDate>Sun, 24 Apr 2016 13:13:35 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/event-broadcasting-in-angular-2/</guid>
      <description>

&lt;p&gt;Angular 1 has an utility for broadcasting an event, &lt;code&gt;$broadcast&lt;/code&gt; and &lt;code&gt;$on&lt;/code&gt;.
Now, Angular 2 dropped these features. Instead it has &lt;code&gt;@Output&lt;/code&gt; annotation and &lt;code&gt;(event)&lt;/code&gt; syntax.
However, we can create a similar utility by using DI; &lt;code&gt;Broadcaster&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;define-broadcaster&#34;&gt;Define &lt;code&gt;Broadcaster&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;First, we have to define &lt;code&gt;Broadcaster&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {Subject} from &#39;rxjs/Subject&#39;;
import {Observable} from &#39;rxjs/Observable&#39;;
import &#39;rxjs/add/operator/filter&#39;;
import &#39;rxjs/add/operator/map&#39;;

interface BroadcastEvent {
  key: any;
  data?: any;
}

export class Broadcaster {
  private _eventBus: Subject&amp;lt;BroadcastEvent&amp;gt;;

  constructor() {
    this._eventBus = new Subject&amp;lt;BroadcastEvent&amp;gt;();
  }

  broadcast(key: any, data?: any) {
    this._eventBus.next({key, data});
  }

  on&amp;lt;T&amp;gt;(key: any): Observable&amp;lt;T&amp;gt; {
    return this._eventBus.asObservable()
      .filter(event =&amp;gt; event.key === key)
      .map(event =&amp;gt; &amp;lt;T&amp;gt;event.data);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Broadcaster&lt;/code&gt; has two methods; &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;on&lt;/code&gt;.
&lt;code&gt;broadcast&lt;/code&gt; will be used to fire an event with event-specific key.
In other hand, &lt;code&gt;on&lt;/code&gt; returns an observable of events which broadcasted the key.&lt;/p&gt;

&lt;p&gt;Angular 1&amp;rsquo;s &lt;code&gt;$broadcast&lt;/code&gt; is used with &lt;strong&gt;string&lt;/strong&gt; key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$broadcast(&#39;MyEvent&#39;, data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we can implement string-based propagation that uses string keys.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// app.ts (application root component)
@Component({
    selector: &#39;app&#39;,
    ...
    providers: [
        // application-shared broadcaster (similar to $rootScope)
        Broadcaster
    ]
})
class App {}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// child.ts
@Component({
    selector: &#39;child&#39;
})
export class ChildComponent {
  constructor(private broadcaster: Broadcaster) {
  }
  
  registerStringBroadcast() {
    this.broadcaster.on&amp;lt;string&amp;gt;(&#39;MyEvent&#39;)
      .subscribe(message =&amp;gt; {
        ...
      });
  }

  emitStringBroadcast() {
    this.broadcaster.broadcast(&#39;MyEvent&#39;, &#39;some message&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great, we regained &lt;code&gt;$rootScope.$broadcast&lt;/code&gt;!
But there are some problems; loosing &lt;strong&gt;typo-safety&lt;/strong&gt; and &lt;strong&gt;type-safety&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;typo-safety&#34;&gt;&lt;em&gt;typo-safety&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;If we mistake the event name, event propagation will be broken, but we cannot get any  &lt;strong&gt;static errors&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;type-safety&#34;&gt;&lt;em&gt;type-safety&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;We cannot know a type of the event data.
Any types will be accepted to the event with same name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$broadcast(&#39;MyEvent&#39;, &#39;100&#39;);
$broadcast(&#39;MyEvent&#39;, 100);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;type-based-event-propagation&#34;&gt;Type-based event propagation&lt;/h2&gt;

&lt;p&gt;So, we should make a safety broadcaster, which uses &lt;strong&gt;types&lt;/strong&gt; to specify an event type.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s make &lt;strong&gt;domain-specific&lt;/strong&gt; broadcaster, &lt;code&gt;MessageEvent&lt;/code&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {Injectable} from &#39;angular2/core&#39;;
import {Observable} from &#39;rxjs/Observable&#39;;
import {Broadcaster} from &#39;./broadcast&#39;;

@Injectable()
export class MessageEvent {
  constructor(private broadcaster: Broadcaster) {}

  fire(data: string): void {
    this.broadcaster.broadcast(MessageEvent, data);
  }

  on(): Observable&amp;lt;string&amp;gt; {
    return this.broadcaster.on&amp;lt;string&amp;gt;(MessageEvent);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we can use it with perfect type-safety! Look at new &lt;code&gt;child.ts&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {Component} from &#39;angular2/core&#39;;
import {MessageEvent} from &#39;../../services/message_event&#39;;

@Component({
  selector: &#39;child&#39;,
  ...
  providers: [ 
    MessageEvent
  ],
})
export class Child {
  constructor(private messageEvent: MessageEvent) {
  }
  
  registerTypeBroadcast() {
    this.messageEvent.on()
      .subscribe(message =&amp;gt; {
        ...
      });
  }
  
  emitTypeBroadcast() {
    this.messageEvent.fire(`Message from ${this.boxID}`);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Demo is &lt;a href=&#34;http://plnkr.co/edit/aJe5SUtFlnpmGXWA5eHk&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article, I explained a way to implement an event propagation like Angular 1&amp;rsquo;s &lt;code&gt;$broadcast&lt;/code&gt;.
And I introduced old string-based event system and type-based safe event system.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular 2のPlatform Provider</title>
      <link>http://blog.lacolaco.net/post/platform-prividers-of-angular-2/</link>
      <pubDate>Fri, 22 Apr 2016 09:48:29 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/platform-prividers-of-angular-2/</guid>
      <description>

&lt;p&gt;Angular 2のDependency Injection(DI)は主にサービスクラスのインスタンスを注入するのに用いられますが、
実は他にも便利な使い方がいくつかあります。
今回はその中から &lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt; と &lt;code&gt;PLATFORM_PIPES&lt;/code&gt; の使い方を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;angular-2のproviderと-multi-オプション&#34;&gt;Angular 2のProviderと&lt;code&gt;multi&lt;/code&gt;オプション&lt;/h2&gt;

&lt;p&gt;まずはじめに、Angular 2のProviderの仕組みについておさらいしましょう。
もしAngular 2のDIがさっぱりわからない方は、先に &lt;a href=&#34;http://qiita.com/laco0416/items/61eed550d1f6070b36ab&#34; target=&#34;_blank&#34;&gt;Angular2のDIを知る&lt;/a&gt; を読むといいかもしれません。&lt;/p&gt;

&lt;p&gt;Angular 2のDIは基本的に、 &lt;strong&gt;トークン&lt;/strong&gt; に対して値をセットします。
TypeScriptでは「型ベースのDI」とよく言われますが、これは型(型アノテーションに使われているクラス)がトークンになっています。
このトークンはクラスじゃなくてもよくて、文字列でも何でも、オブジェクトであれば何でも許容されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;providers: [
    MyClass, // 自動的にMyClassがインスタンス化される
    new Provider(MyClass, {useClass: MyClass}), // 上と同義
    new Provider(&amp;quot;myValue&amp;quot;, {useValue: &amp;quot;value&amp;quot;}, // 文字列をトークンにする 
]    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Angular 2では、トークンを定数として提供して、ユーザーが値を自由にセットできるようにしているものがいくつかあります。
代表的なのは&lt;code&gt;APP_BASE_HREF&lt;/code&gt;です。これはAngular 2の&lt;code&gt;Location&lt;/code&gt;がベースパスとして使うバスを設定するためのトークンです&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new Provider(APP_BASE_HREF, {useValue: &amp;quot;/basepath/&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにもう一つ重要なのは、&lt;code&gt;＠Component&lt;/code&gt;や&lt;code&gt;bootstrap&lt;/code&gt;でProviderが要求される場面では、Providerの配列を渡せるということです。
配列を渡した場合は内部で自動的に展開されるので、複数のProviderが依存しあっている場合に1つの配列にまとめることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const MY_PROVIDERS = [
    MyClassA,
    new Provider(MyClassB, {useValue: new MyClassB(&amp;quot;initial&amp;quot;)}),
    new Provider(MyClassC, {
        useFactory: (myClassA: MyClassA, myClassB: myClassB) =&amp;gt; {
            myClassA.init();
            return new MyClassC(myClassA, myClassB);
        },
        deps: [MyClassA, MyClassB]
    }
]

...

providers: [
     MY_PROVIDERS
]    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;multi-オプション&#34;&gt;&lt;code&gt;multi&lt;/code&gt; オプション&lt;/h3&gt;

&lt;p&gt;さて、Angular 2のDIの基礎を振り返ったところで、ここから先の話で必要になるのが &lt;code&gt;multi&lt;/code&gt;オプションです。
Providerは、同じトークンに対して2回値をセットすると、先にProvideした方は上書きされてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;[
    MyClass,
    new Provider(MyClass, {useClass: MockMyClass}) // 上書きする
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;multi&lt;/code&gt;オプションは、同じトークンに対して複数のProvideを行うときに、上書きではなく &lt;strong&gt;追加&lt;/strong&gt; を行います。
次の例では、複数のクラスをまとめるトークンを作り、&lt;code&gt;multi&lt;/code&gt;で追加しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;[
    new Provider(MY_PROVIDERS, {useClass: MyClassA, multi: true}),
    new Provider(MY_PROVIDERS, {useClass: MyClassB, multi: true}),
    new Provider(MY_PROVIDERS, {useClass: MyClassC, multi: true}),
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このオプションを使うことで、配列をInjectしたい場合にその要素を動的に追加することができます。&lt;/p&gt;

&lt;h2 id=&#34;platform-directives-トークン&#34;&gt;&lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt; トークン&lt;/h2&gt;

&lt;p&gt;というわけで、ようやく本題に入れます！
&lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt;トークンは、&lt;code&gt;multi&lt;/code&gt;オプションでProviderを追加されることを想定してAngular 2が提供しているものです。
その名の通り、プラットフォーム全体で使えるディレクティブを提供するトークンです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/core/PLATFORM_DIRECTIVES-let.html&#34; target=&#34;_blank&#34;&gt;PLATFORM_DIRECTIVES - ts&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えば、アプリケーション全体で使うモーダルのコンポーネント &lt;code&gt;ModalComponent&lt;/code&gt; を作ったとしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
    selector: &amp;quot;my-modal&amp;quot;,
    template: `...`
})
class ModalComponent {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコンポーネントを別のコンポーネントから使うには、使う側のコンポーネントの &lt;code&gt;directives&lt;/code&gt; にクラスを指定しないといけません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
    selector: &amp;quot;my-app&amp;quot;,
    template: &amp;quot;&amp;lt;my-model&amp;gt;&amp;lt;/my-model&amp;gt;&amp;quot;,
    directives: [ModalComponent]
})
class AppComponent {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;ModalComponent&lt;/code&gt;を他にも多くのコンポーネントから呼び出す時、毎回&lt;code&gt;directives&lt;/code&gt;を設定するのは面倒ですね？
そんな時に&lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt;の出番です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt;に&lt;code&gt;ModalComponent&lt;/code&gt;を追加することで、プラットフォームの共通ディレクティブであるとして自動的に解決してくれるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new Provider(PLATFORM_DIRECTIVES, {useValue: [ModalComponent], multi: true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もっとも便利なユースケースは、&lt;code&gt;ROUTER_DIRECTIVES&lt;/code&gt;でしょう。
angular2/routerが提供している&lt;code&gt;routerLink&lt;/code&gt;や&lt;code&gt;&amp;lt;router-outlet&amp;gt;&lt;/code&gt;をコンポーネントから使うには、&lt;code&gt;directives: [ROUTER_DIRECTIVES]&lt;/code&gt; という記述が必要です。
ここで&lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt;を使うと、アプリケーション全体でどこでも使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new Provider(PLATFORM_DIRECTIVES, {useValue: ROUTER_DIRECTIVES, multi: true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;汎用的なコンポーネントやディレクティブを作った時には、ぜひ活用してみてください。&lt;/p&gt;

&lt;h2 id=&#34;platform-pipes&#34;&gt;&lt;code&gt;PLATFORM_PIPES&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ここまで理解した方ならもう説明の必要はないでしょう。名前の通り、プラットフォーム全体で使えるパイプを定義できるトークンです。
汎用的なパイプを作った時に活用すると、毎回 &lt;code&gt;pipes: [MyPipe]&lt;/code&gt; を書く必要はありません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/compiler/PLATFORM_PIPES-let.html&#34; target=&#34;_blank&#34;&gt;PLATFORM_PIPES - ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new Provider(PLATFORM_PIPES, {useValue: [MyPipe], multi:true});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;おまけ-opaquetoken&#34;&gt;おまけ: &lt;code&gt;OpaqueToken&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;もし &lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt;や&lt;code&gt;PLATFORM_PIPES&lt;/code&gt;というトークンがどうやって作られいるのか気になった方は、無事にAngular 2中級者への階段を踏み出しています！
これらは &lt;code&gt;OpaqueToken&lt;/code&gt; というクラスのインスタンスになっています。
このクラスは、Providerのトークンとして使いやすいインスタンスを提供してくれます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/core/OpaqueToken-class.html&#34; target=&#34;_blank&#34;&gt;OpaqueToken - ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;var t = new OpaqueToken(&amp;quot;value&amp;quot;);
var injector = Injector.resolveAndCreate([
  provide(t, {useValue: &amp;quot;bindingValue&amp;quot;})
]);
expect(injector.get(t)).toEqual(&amp;quot;bindingValue&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定数として&lt;code&gt;OpaqueToken&lt;/code&gt;のインスタンスを作っておいてアプリケーションで使うようにすると、柔軟なDIを行うことができるでしょう！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PLATFORM_DIRECTIVES&lt;/code&gt;と&lt;code&gt;PLATFORM_PIPES&lt;/code&gt;を使うと、
汎用的なコンポーネントやディレクティブ、パイプを毎回宣言することなく、どこでも使えるようになります。
アプリケーションが大きくなってきたらぜひ活用してみてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular 2のデフォルトルートとotherwiseルート</title>
      <link>http://blog.lacolaco.net/post/otherwise-and-default-in-angular-2/</link>
      <pubDate>Sun, 17 Apr 2016 11:25:31 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/otherwise-and-default-in-angular-2/</guid>
      <description>

&lt;p&gt;この記事ではAngular 2のルーターが持つ &lt;strong&gt;useAsDefault&lt;/strong&gt; と &lt;strong&gt;otherwise&lt;/strong&gt; の違いと、その使い方について解説します。
この2つを使い分けることで柔軟なルーティングを定義することができます。&lt;/p&gt;

&lt;h2 id=&#34;ルートの定義&#34;&gt;ルートの定義&lt;/h2&gt;

&lt;p&gt;まず最初に、RouteConfigが適用されているコンポーネントを、この記事では &lt;em&gt;RouteComponent&lt;/em&gt; と呼ぶことにします。
RouteComponentが表示された時、RouteComponentはその時点のURLのパスを元に、ルーティングを行います。
次の例では、PageAとPageBのそれぞれのルートを定義しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@RouteConfig([
  {path: &amp;quot;/pageA&amp;quot;, component: PageA, name: &amp;quot;PageA&amp;quot;},
  {path: &amp;quot;/pageB&amp;quot;, component: PageB, name: &amp;quot;PageB&amp;quot;},
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、現在のパスが &lt;code&gt;/pageA&lt;/code&gt; にも &lt;code&gt;/pageB&lt;/code&gt; にも一致しない時はどうなるのでしょうか？&lt;/p&gt;

&lt;h3 id=&#34;ルートパスに一致させる&#34;&gt;ルートパスに一致させる&lt;/h3&gt;

&lt;p&gt;例えば、アプリケーションの起動直後にパスが ルートパス( &lt;code&gt;/&lt;/code&gt; ) だったときにデフォルトで表示したいページがあるとします。
このルート定義では、どちらのルートにもマッチしないのでRouteComponentそのものが表示されるだけでルーティングは行われません。&lt;/p&gt;

&lt;p&gt;もし、ルートパスにデフォルトでPageAを表示しておきたいのであれば、 &lt;code&gt;useAsDefault&lt;/code&gt; プロパティを使い、デフォルトルートを定義することができます。
次の例を見てください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@RouteConfig([
  {path: &amp;quot;/pageA&amp;quot;, component: PageA, name: &amp;quot;PageA&amp;quot;, useAsDefault: true},
  {path: &amp;quot;/pageB&amp;quot;, component: PageB, name: &amp;quot;PageB&amp;quot;},
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PageAのルート定義に &lt;code&gt;useAsDefault&lt;/code&gt; プロパティを追加し、 &lt;code&gt;true&lt;/code&gt; を渡しています。
こうすることで、RouteComponentはルートパスにアクセスされた時、PageAにルーティングしてくれます。&lt;/p&gt;

&lt;p&gt;ただし、デフォルトルートはあくまでも &lt;strong&gt;ルートパスに結びつける&lt;/strong&gt; のであって、 それ以外の場合には適用されません。
具体的には、 &lt;code&gt;/pageC&lt;/code&gt; にアクセスされた時には、やはりどのルートにもマッチせず、ルーティングが行われません。&lt;/p&gt;

&lt;h3 id=&#34;otherwiseルートを定義する&#34;&gt;otherwiseルートを定義する&lt;/h3&gt;

&lt;p&gt;そんなときに使えるのが &lt;strong&gt;otherwiseルート&lt;/strong&gt; です。
もしあなたがAngularJSのui-routerを使っていたら、馴染みのある機能かもしれません。
otherwiseとは言葉どおり「その他」を定義できる機能です。つまり、どのルートにもマッチしない時にどうするかを設定することができるのです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angular2/router&lt;/code&gt;では、otherwiseルートは次のように定義できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  {path: &amp;quot;/**&amp;quot;, ...},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パスの値は &lt;code&gt;/**&lt;/code&gt; 以外にも &lt;code&gt;/*foo&lt;/code&gt; や &lt;code&gt;/*other&lt;/code&gt; などでも可能です。ただし &lt;code&gt;/*&lt;/code&gt; は使えません。
想定外のURLにアクセスされたときにデフォルトでPageAにリダイレクトさせたければ、次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@RouteConfig([
  {path: &amp;quot;/pageA&amp;quot;, component: PageA, name: &amp;quot;PageA&amp;quot;},
  {path: &amp;quot;/pageB&amp;quot;, component: PageB, name: &amp;quot;PageB&amp;quot;},
  {path: &amp;quot;/**&amp;quot;, redirectTo: [&amp;quot;PageA&amp;quot;]},
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろんリダイレクトではなく通常のルートとして404用のコンポーネントにルーティングすることもできるでしょう。
すべては設定次第です。&lt;/p&gt;

&lt;h3 id=&#34;デフォルトルート-vs-otherwiseルート&#34;&gt;デフォルトルート vs otherwiseルート&lt;/h3&gt;

&lt;p&gt;otherwiseルートはデフォルトルートよりも優先度が高いので、
もしotherwiseルートが定義されている場合はルートパスでもotherwiseルートが適用されます。
そのため、トップレベルのRouteComponentではotherwiseを使うと良いでしょう。&lt;/p&gt;

&lt;p&gt;デフォルトルートは 非終端ルート( &lt;code&gt;/...&lt;/code&gt; ) により入れ子になったルートの定義で使います。
&lt;code&gt;/nested/...&lt;/code&gt; というパスでルーティングされる先のコンポーネントでは、
RouteConfigに必ず1つデフォルトルートを定義する必要があります。
なぜなら &lt;code&gt;/nested/&lt;/code&gt; にアクセスされたときに表示するコンポーネントが必要だからです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;この記事ではデフォルトルートとotherwiseルートの使い方と違いについて解説しました。
もしAngular 2のルーティングについてもっと広く知りたければ、
公式ドキュメントの &lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html&#34; target=&#34;_blank&#34;&gt;Routing &amp;amp; Navigation&lt;/a&gt; を読むとよいでしょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[日本語訳] ViewChildren and ContentChildren in Angular 2</title>
      <link>http://blog.lacolaco.net/post/translation-view-children-and-content-children-in-angular-2/</link>
      <pubDate>Sat, 16 Apr 2016 11:15:00 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/translation-view-children-and-content-children-in-angular-2/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Original: &lt;a href=&#34;http://blog.mgechev.com/2016/01/23/angular2-viewchildren-contentchildren-difference-viewproviders/&#34; target=&#34;_blank&#34;&gt;ViewChildren and ContentChildren in Angular 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Written by: &lt;a href=&#34;http://twitter.com/mgechev&#34; target=&#34;_blank&#34;&gt;Minko Gechev&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Translated at: 04/16/2016&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;この記事ではAngular 2の &lt;strong&gt;View Children&lt;/strong&gt; と &lt;strong&gt;Content Children&lt;/strong&gt; の違いについて解説します。&lt;/p&gt;

&lt;p&gt;それぞれの子要素に対して、親コンポーネントからどのようにアクセスするのかを理解し、
そして&lt;code&gt;@Component&lt;/code&gt;デコレータの &lt;code&gt;providers&lt;/code&gt; と &lt;code&gt;viewProviders&lt;/code&gt; の2つのプロパティの違いについても述べていきます。&lt;/p&gt;

&lt;h2 id=&#34;プリミティブの合成&#34;&gt;プリミティブの合成&lt;/h2&gt;

&lt;p&gt;まず初めに、Angular 2のコンポーネントとディレクティブの関係についておさらいしましょう。
ユーザーインタフェースを作るのに一般的なデザインは&lt;a href=&#34;https://ja.wikipedia.org/wiki/Composite_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34; target=&#34;_blank&#34;&gt;Compositeパターン&lt;/a&gt;です。
このデザインパターンは異なるプリミティブを合成し、1つのインスタンスとして同じ方法で扱えるようにします。
関数型プラグラミングの世界では関数を合成することもできます。例えば次のように&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map ((*2).(+1)) [1, 2, 3]
-- [4,6,8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このHaskellのコードは&lt;code&gt;(*2)&lt;/code&gt;と&lt;code&gt;(+1)&lt;/code&gt;という2つの関数を合成し、
リスト内の各アイテム&lt;code&gt;n&lt;/code&gt;に対して&lt;code&gt;n -&amp;gt; + 1 -&amp;gt; * 2&lt;/code&gt;という流れで適用されます。&lt;/p&gt;

&lt;h2 id=&#34;uiにおける合成&#34;&gt;UIにおける合成&lt;/h2&gt;

&lt;p&gt;ユーザーインタフェースにおいても同じことがいえます。
コンポーネントを1つの関数として見てみましょう。
各関数は順序に従って合成可能であり、結果として複雑なコンポーネントを作ることができます。&lt;/p&gt;

&lt;p&gt;この構造は次の図で表すことができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mgechev.com/images/component-directive-angular2.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この図には2つの要素があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Directive: ロジックを持った要素ですが、構造は内包していません。&lt;/li&gt;
&lt;li&gt;Component: 1つの要素であり、1つのディレクティブでもあります。そして複数のディレクティブを内包しています。(コンポーネントを内包することもできます)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはつまり、次のような構造を作ることができるということです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mgechev.com/images/component-tree-angular2.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上の図を見ると、コンポーネントとディレクティブによる階層構造ができていることがわかります。
末端の要素はディレクティブか、ディレクティブを内包しないコンポーネントのどちらかになります。&lt;/p&gt;

&lt;h2 id=&#34;angular-2におけるコンポーネントの合成&#34;&gt;Angular 2におけるコンポーネントの合成&lt;/h2&gt;

&lt;p&gt;さて、そろそろAngular 2の具体的な話をしましょう。&lt;/p&gt;

&lt;p&gt;これから説明することをわかりやすくするために、簡単なアプリケーションを作っていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// ...
@Component({
  selector: &#39;todo-app&#39;,
  providers: [TodoList],
  directives: [TodoCmp, TodoInputCmp],
  template: `
    &amp;lt;section&amp;gt;
      Add todo:
      &amp;lt;todo-input (onTodo)=&amp;quot;addTodo($event)&amp;quot;&amp;gt;&amp;lt;/todo-input&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;section&amp;gt;
      &amp;lt;h4 *ngIf=&amp;quot;todos.getAll().length&amp;quot;&amp;gt;Todo list&amp;lt;/h4&amp;gt;
      &amp;lt;todo *ngFor=&amp;quot;var todo of todos.getAll()&amp;quot; [todo]=&amp;quot;todo&amp;quot;&amp;gt;
      &amp;lt;/todo&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;ng-content select=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/ng-content&amp;gt;
  `
})
class TodoAppCmp {
  constructor(private todos: TodoList) {}
  addTodo(todo) {
    this.todos.add(todo);
  }
}
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは &lt;em&gt;Yet another MV* todo application&lt;/em&gt; です. (訳注：アプリケーションの名前なのでそのまま残しています。)&lt;/p&gt;

&lt;p&gt;上では &lt;code&gt;todo-app&lt;/code&gt; というセレクタで、テンプレートを持ったコンポーネントを定義しています。
そして、子要素として使われるディレクティブのセットを定義しています。&lt;/p&gt;

&lt;p&gt;このコンポーネントは次のように使われます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;todo-app&amp;gt;&amp;lt;/todo-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは標準的なXMLの構文なので、
開始タグと終了タグの間に任意のcontentを挿入することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;todo-app&amp;gt;
  &amp;lt;footer&amp;gt;
    Yet another todo app!
  &amp;lt;/footer&amp;gt;
&amp;lt;/todo-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ng-content-による基本的なcontentの表示&#34;&gt;&lt;code&gt;ng-content&lt;/code&gt; による基本的なcontentの表示&lt;/h2&gt;

&lt;p&gt;ここで &lt;code&gt;todo-app&lt;/code&gt; コンポーネントの定義にちょっと戻りましょう。
テンプレートの最後の要素 &lt;code&gt;&amp;lt;ng-content select=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/ng-content&amp;gt;&lt;/code&gt; に気づきましたか？
&lt;code&gt;ng-content&lt;/code&gt; を使うと、そのコンポーネントの開始タグと終了タグの間に置かれたcontentを、テンプレートの中に投影することができます！
&lt;code&gt;ng-content&lt;/code&gt; に与えている &lt;code&gt;select&lt;/code&gt; 属性はCSSのセレクタで、contentの中から投影するものを選ぶことができます。
上の例では &lt;code&gt;footer&lt;/code&gt; が &lt;code&gt;todo-app&lt;/code&gt; コンポーネントの一番下に挿入されます。&lt;/p&gt;

&lt;p&gt;もし &lt;code&gt;select&lt;/code&gt; 要素を省いた場合は、content全体が投影されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;todo-input&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;todo&amp;gt;&lt;/code&gt; の2つのコンポーネントについては今回の話には関係ないので実装部分を省略していますが、
このアプリケーションの完成形はこんな感じになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.mgechev.com/images/todo-app-sample.gif&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;viewchildren-と-contentchildren&#34;&gt;ViewChildren と ContentChildren&lt;/h2&gt;

&lt;p&gt;ここまでは簡単でしたね！さて、ようやくView ChildrenとContent Childrenという概念を定義する準備ができました。&lt;/p&gt;

&lt;p&gt;その定義とは、「テンプレートの中に配置された子要素を &lt;em&gt;View Children&lt;/em&gt; と呼ぶ」、
そして「開始タグと終了タグの間に置かれた要素を &lt;em&gt;Content Children&lt;/em&gt; と呼ぶ」です。&lt;/p&gt;

&lt;p&gt;つまり、&lt;code&gt;todo-input&lt;/code&gt; と &lt;code&gt;todo&lt;/code&gt; の2つの要素は &lt;code&gt;todo-app&lt;/code&gt; にとっての View Childrenであり、
&lt;code&gt;footer&lt;/code&gt; はContent Childであるというわけです。&lt;/p&gt;

&lt;h3 id=&#34;子要素にアクセスする&#34;&gt;子要素にアクセスする&lt;/h3&gt;

&lt;p&gt;ようやく本題に入れます！2種類の子要素にどうやってアクセスし、操作するのか、その方法を見ていきましょう！&lt;/p&gt;

&lt;h4 id=&#34;view-childrenを使った例&#34;&gt;View Childrenを使った例&lt;/h4&gt;

&lt;p&gt;Angular 2では次のプロパティデコレータを &lt;code&gt;angular2/core&lt;/code&gt; パッケージで提供しています。：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@ViewChildren&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ViewChild&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ContentChildren&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ContentChild&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これは次のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {ViewChild, ViewChildren, Component...} from &#39;angular2/core&#39;;

// ...

@Component({
  selector: &#39;todo-app&#39;,
  providers: [TodoList],
  directives: [TodoCmp, TodoInputCmp],
  template: `...`
})
class TodoAppCmp {
  @ViewChild(TodoInputCmp)
  inputComponent: TodoInputCmp
  
  @ViewChildren(TodoCmp)
  todoComponents: QueryList&amp;lt;TodoCmp&amp;gt;;

  constructor(private todos: TodoList) {}
  ngAfterViewInit() {
    // available here
  }
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の例では、 &lt;code&gt;@ViewChildren&lt;/code&gt; と &lt;code&gt;@ViewChild&lt;/code&gt; を使っています。
プロパティをデコレートすると、要素をクエリできるようになります。
上の例だと、子コンポーネントである &lt;code&gt;TodoInputCmp&lt;/code&gt; を &lt;code&gt;@ViewChild&lt;/code&gt;で、 &lt;code&gt;TodoCmp&lt;/code&gt; を &lt;code&gt;@ViewChildren&lt;/code&gt; でクエリしています。
2つのデコレータを使い分けている理由は、 &lt;code&gt;TodoInputCmp&lt;/code&gt; は1つしかないので &lt;code&gt;@ViewChild&lt;/code&gt; を使えますが、 &lt;code&gt;TodoCmp&lt;/code&gt; は複数個が表示されるので &lt;code&gt;@ViewChildren&lt;/code&gt; を使う必要があるからです。&lt;/p&gt;

&lt;p&gt;もう一つ重要なことは、 &lt;code&gt;inputComponent&lt;/code&gt; と &lt;code&gt;todoComponents&lt;/code&gt; の型です。
前者のプロパティの型は &lt;code&gt;TodoInputCmp&lt;/code&gt; になっています。
これはクエリした結果要素が見つからなければnullになり、見つかればそのコンポーネントのインスタンスが代入されます。
一方、 &lt;code&gt;todoComponents&lt;/code&gt; プロパティの型は &lt;code&gt;QueryList&amp;lt;TodoCmp&amp;gt;&lt;/code&gt; で、動的に増えたり減ったりする &lt;code&gt;TodoCmp&lt;/code&gt;のインスタンスを扱えます。
&lt;code&gt;QueryList&lt;/code&gt; はObservableなコレクションなので、新しく追加されたり、要素が削除された時にはイベントを発生してくれます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AngularのDOMコンパイラは &lt;code&gt;todo-app&lt;/code&gt; コンポーネントを先に初期化し、その後子要素を初期化します。&lt;/strong&gt;
&lt;strong&gt;つまり &lt;code&gt;todo-app&lt;/code&gt; コンポーネントの初期化の間は &lt;code&gt;inputComponent&lt;/code&gt; も &lt;code&gt;todoComponents&lt;/code&gt; もまだ初期化されていません&lt;/strong&gt;
&lt;strong&gt;これらは &lt;code&gt;ngAfterCiewInit&lt;/code&gt; ライフサイクルフックのタイミングで使用可能になります&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;content-childrenにアクセスする&#34;&gt;Content Childrenにアクセスする&lt;/h4&gt;

&lt;p&gt;Content Childrenについてもほとんど同じルールが通用しますが、少しだけ違いがあります。
それを説明するために、 &lt;code&gt;TodoAppCmp&lt;/code&gt; を使う側のルートコンポーネントを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt; @Component({
  selector: &#39;footer&#39;,
  template: &#39;&amp;lt;ng-content&amp;gt;&amp;lt;/ng-content&amp;gt;&#39;
})
class Footer {}

@Component(...)
class TodoAppCmp {...}

@Component({
  selector: &#39;app&#39;,
  styles: [
    &#39;todo-app { margin-top: 20px; margin-left: 20px; }&#39;
  ],
  template: `
    &amp;lt;content&amp;gt;
      &amp;lt;todo-app&amp;gt;
        &amp;lt;footer&amp;gt;
          &amp;lt;small&amp;gt;Yet another todo app!&amp;lt;/small&amp;gt;
        &amp;lt;/footer&amp;gt;
      &amp;lt;/todo-app&amp;gt;
    &amp;lt;/content&amp;gt;
  `,
  directives: [TodoAppCmp, NgModel, Footer]
})
export class AppCmp {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは2つのコンポーネント &lt;code&gt;Footer&lt;/code&gt; と &lt;code&gt;AppCmp&lt;/code&gt; を定義しています。
&lt;code&gt;Footer&lt;/code&gt; は開始タグと終了タグの間に渡された要素をすべて投影します( &lt;code&gt;&amp;lt;footer&amp;gt;ここが表示されます&amp;lt;/footer&amp;gt;&lt;/code&gt; )
一方、 &lt;code&gt;AppCmp&lt;/code&gt; は &lt;code&gt;TodoAppCmp&lt;/code&gt; を使い、さらに &lt;code&gt;Footer&lt;/code&gt; を開始タグと終了タグの間に渡しています。
つまり、これは我々の用語では &lt;code&gt;Footer&lt;/code&gt; はContent Childであるといえます。これにアクセスするには次の例のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// ...
@Component(...)
class TodoAppCmp {
  @ContentChild(Footer)
  footer: Footer;
  
  ngAfterContentInit() {
    // this.footer is now with value set
  }
}
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;View ChildrenとContent Childrenの違いは、使っているデコレータとライフサイクルフックの種類だけです。
Content Childrenには &lt;code&gt;@ContentChild&lt;/code&gt; または &lt;code&gt;@ContentChildren&lt;/code&gt; デコレータを使い、
&lt;code&gt;ngAfterContentInit&lt;/code&gt; ライフサイクルで使用可能になります。&lt;/p&gt;

&lt;h2 id=&#34;viewproviders-と-providers&#34;&gt;&lt;code&gt;viewProviders&lt;/code&gt; と &lt;code&gt;providers&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;もうほとんど説明は終わってしまいました！
最後のステップは、 &lt;code&gt;providers&lt;/code&gt; と &lt;code&gt;viewProviders&lt;/code&gt; の違いを理解することです。
(もしあなたがAngular 2のDIのメカニズムを理解していなければ、まず &lt;a href=&#34;https://www.packtpub.com/web-development/switching-angular-2&#34; target=&#34;_blank&#34;&gt;私の本&lt;/a&gt; を読むといいでしょう)&lt;/p&gt;

&lt;p&gt;さて、それでは &lt;code&gt;TodoAppCmp&lt;/code&gt; の宣言部分を覗いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class TodoList {
  private todos: Todo[] = [];
  add(todo: Todo) {}
  remove(todo: Todo) {}
  set(todo: Todo, index: number) {}
  get(index: number) {}
  getAll() {}
}

@Component({
  // ...
  viewProviders: [TodoList],
  directives: [TodoCmp, TodoInputCmp],
  // ...
})
class TodoAppCmp {
  constructor(private todos: TodoList) {}
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@Component&lt;/code&gt; デコレータの中で &lt;code&gt;viewProviders&lt;/code&gt; プロパティがセットされ、 &lt;code&gt;TodoList&lt;/code&gt; サービスが渡されています。
&lt;code&gt;TodoList&lt;/code&gt; サービスはすべてのTodoのアイテムを保持しているサービスです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TodoAppCmp&lt;/code&gt; のコンストラクタでは &lt;code&gt;TodoList&lt;/code&gt; をインジェクトしていますが、
これは &lt;code&gt;TodoAppCmp&lt;/code&gt; コンポーネントの中で使われている他のディレクティブ(もちろんコンポーネントも)でもインジェクト可能です。
つまり、 &lt;code&gt;TodoList&lt;/code&gt; は次の場所からアクセス可能です&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TodoAppCmp&lt;/li&gt;
&lt;li&gt;TodoCmp&lt;/li&gt;
&lt;li&gt;TodoInputCmp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ところが、 &lt;code&gt;Footer&lt;/code&gt; コンポーネントのコンストラクタでこのサービスをインジェクトしようとすると、次のようなエラーが表示されるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXCEPTION: No provider for TodoList! (Footer -&amp;gt; TodoList)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;これは &lt;code&gt;viewProviders&lt;/code&gt; によって宣言されたプロバイダはそのコンポーネントとView Childrenにだけアクセス可能になるということです&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Footer&lt;/code&gt; でも &lt;code&gt;TodoList&lt;/code&gt; サービスにアクセスしたい場合は、 &lt;code&gt;viewProviders&lt;/code&gt; から &lt;code&gt;providers&lt;/code&gt; に変える必要があります。&lt;/p&gt;

&lt;h3 id=&#34;viewproviders-はいつ使うべき&#34;&gt;&lt;code&gt;viewProviders&lt;/code&gt; はいつ使うべき？&lt;/h3&gt;

&lt;p&gt;いったいどういう時に、Content Childrenからアクセスできないように &lt;code&gt;viewProviders&lt;/code&gt; を使うべきなのでしょうか？
仮にあなたがサードパーティのライブラリを作り、その中でインターナルなサービスを使うとします。
そのサービスはライブラリの内部的なAPIの一部で、他のユーザーからはアクセスさせたくないものです。
そのようなプライベートな依存性を &lt;code&gt;providers&lt;/code&gt; を使って登録し、ライブラリで公開しているコンポーネントの中にユーザーがContent Childrenを渡すと、
その人はアクセスできてしまいます。
しかし、あなたが &lt;code&gt;viewProviders&lt;/code&gt; を使えば、そのサービスは外からは使えなくなります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;この記事ではコンポーネントとディレクティブの合成の方法について解説しました。
また、View ChildrenとContent Childrenの違いと、それらにどうやってアクセスするのかについても紹介しました。&lt;/p&gt;

&lt;p&gt;そして最後に、 &lt;code&gt;viewProviders&lt;/code&gt; と &lt;code&gt;providers&lt;/code&gt; の意味についても説明しました。
もしこのテーマにもっと興味がある場合は、私が書いている&lt;a href=&#34;https://www.packtpub.com/web-development/switching-angular-2&#34; target=&#34;_blank&#34;&gt;Switching to Angular 2&lt;/a&gt;を読むことをおすすめします！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[日本語訳] Angular 2 Component Styles</title>
      <link>http://blog.lacolaco.net/post/translation-angular-2-component-styles/</link>
      <pubDate>Sat, 16 Apr 2016 00:27:46 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/translation-angular-2-component-styles/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Original: &lt;a href=&#34;https://angular.io/docs/ts/latest/guide/component-styles.html&#34; target=&#34;_blank&#34;&gt;Component Styles - ts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Written by: &lt;a href=&#34;https://angular.io&#34; target=&#34;_blank&#34;&gt;angular.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Translated at: 04/15/2016&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;コンポーネントのスタイル&#34;&gt;コンポーネントのスタイル&lt;/h1&gt;

&lt;p&gt;Angular 2のアプリケーションは標準のCSSによってスタイリングすることができます。
つまり、CSSのスタイルシートやセレクタ、ルールやメディアクエリなどについて知っていることをそのままAngular 2のアプリケーションに適用できます。&lt;/p&gt;

&lt;p&gt;さらに、Angular 2はCSSのスタイルシートをモジュール化し、コンポーネントに同梱することが可能です。&lt;/p&gt;

&lt;p&gt;この章ではどのようにして &lt;strong&gt;コンポーネントスタイル&lt;/strong&gt; を読み込み、適用するかについて解説します。&lt;/p&gt;

&lt;h2 id=&#34;コンポーネントスタイルを使う&#34;&gt;コンポーネントスタイルを使う&lt;/h2&gt;

&lt;p&gt;Angular 2のコンポーネントを書くとき、HTMLのテンプレートだけでなく、CSSのスタイルも決めるでしょう。
コンポーネントのテンプレートに対してスタイルを適用する1つの方法は、コンポーネントのメタデータ中の&lt;code&gt;styles&lt;/code&gt;プロパティを使うことです。
&lt;code&gt;styles&lt;/code&gt;プロパティはstringの配列としてCSSを受け取ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;hero-app&#39;,
  template: `
    &amp;lt;h1&amp;gt;Tour of Heroes&amp;lt;/h1&amp;gt;
    &amp;lt;hero-app-main [hero]=hero&amp;gt;&amp;lt;/hero-app-main&amp;gt;`,
  styles: [&#39;h1 { font-weight: normal; }&#39;],
  directives: [HeroAppMainComponent]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンポーネントスタイルはこれまでのグローバルのスタイルとはいくつか違いが有ります。&lt;/p&gt;

&lt;p&gt;第一に、セレクタはそのコンポーネントのテンプレート内にしか適用されません。
上の例にある&lt;code&gt;h1 { }&lt;/code&gt;セレクタは、&lt;code&gt;hero-app&lt;/code&gt;コンポーネントのテンプレート内にある&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;タグにだけ適用され、
それ以外の他の場所には影響しません。&lt;/p&gt;

&lt;p&gt;これは古典的なCSSとくらべてモジュール化において大きな改良点です。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;コンポーネントのコンテキストの中で、直感的なセレクタやクラス名を使うことができます&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;クラス名やセレクタがアプリケーション中で衝突することを気にする必要がありません&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;コンポーネントのスタイルが別の場所から書き換えられることがありません&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;プロジェクトの構造が変わり、CSSのコードをTypeScriptやHTMLと同じディレクトリに置くことができます。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将来的にCSSのコードを変えたり削除したりする際に、そのスタイルが他の場所で使われていないかを気にしなくてよいです&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;特殊セレクタ&#34;&gt;特殊セレクタ&lt;/h2&gt;

&lt;p&gt;コンポーネントスタイルでは&lt;a href=&#34;https://www.w3.org/TR/css-scoping-1/&#34; target=&#34;_blank&#34;&gt;Shadow DOM&lt;/a&gt;に由来するいくつかの特殊なセレクタを使うことができます。&lt;/p&gt;

&lt;h3 id=&#34;host&#34;&gt;&lt;code&gt;:host&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;:host&lt;/code&gt;擬似クラスセレクタは、そのコンポーネント自身にマッチします。(コンポーネント内のすべての要素にヒットするわけではありません)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;:host {
  display: block;
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはホスト要素にアクセスする唯一の方法です。
他のセレクタではコンポーネント自身にマッチすることはできません。
なぜならコンポーネントの要素はそのコンポーネントのテンプレートの一部ではないからです。
ホスト要素は、その親のコンポーネントのテンプレート内の要素です。&lt;/p&gt;

&lt;p&gt;カッコとセレクタを使って表現する &lt;em&gt;関数フォーム&lt;/em&gt; を使って、ホストのスタイルを状態に応じて変えることができます。
次の例では、自身に&lt;code&gt;active&lt;/code&gt;クラスが付いているときだけ適用するスタイルを宣言しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;:host(.active) {
  border-width: 3px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;host-context&#34;&gt;&lt;code&gt;:host-context&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;:host-context&lt;/code&gt;セレクタは、コンポーネントの &lt;em&gt;外&lt;/em&gt; の状態に応じたスタイルを書くときに便利です。
例えば、CSSのテーマのクラスがドキュメントの&lt;code&gt;body&lt;/code&gt;に適用されているとき、
コンポーネントのスタイルもそれに追従したい場合があるでしょう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:host-context&lt;/code&gt;擬似クラスセレクタは、&lt;code&gt;:host&lt;/code&gt;の関数フォームと同じように動作します。
コンポーネントのホスト要素の親 &lt;em&gt;すべて&lt;/em&gt; に、該当するセレクタを持っていないかをチェックします。&lt;/p&gt;

&lt;p&gt;次の例ではコンポーネント中の&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;要素の&lt;code&gt;background-color&lt;/code&gt;スタイルを、祖先の要素が&lt;code&gt;theme-light&lt;/code&gt;を持っている時だけ変更するように書いています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;:host-context(.theme-light) h2 {
  background-color: #eef;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;deep&#34;&gt;&lt;code&gt;/deep/&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;コンポーネントスタイルは基本的に、自身のテンプレート内にしか適用されません。&lt;/p&gt;

&lt;p&gt;ただし、&lt;code&gt;/deep/&lt;/code&gt;セレクタを使うと、強制的に子コンポーネントの内部にスタイルを適用することができます。
ネストはどこまででも深く適用され、テンプレート中の子だけでなく、contentとしての子にも作用します。&lt;/p&gt;

&lt;p&gt;次の例では、コンポーネント自身とその子すべてが持つ&lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt;要素にマッチするCSSを書いています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;:host /deep/ h3 {
  font-style: italic;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/deep/&lt;/code&gt;セレクタは&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;と書くこともできます。&lt;/p&gt;

&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/deep/&lt;/code&gt;と&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;は&lt;code&gt;ViewEncapsulation.Emulated&lt;/code&gt;でしか使えません。
&lt;code&gt;ViewEncapsulation.Emulated&lt;/code&gt;はコンポーネントのデフォルトの設定です。&lt;/p&gt;

&lt;h2 id=&#34;スタイルをコンポーネントへ読み込む方法&#34;&gt;スタイルをコンポーネントへ読み込む方法&lt;/h2&gt;

&lt;p&gt;コンポーネントにスタイルを追加する方法はいくつかあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;テンプレートHTML中に記述する方法&lt;/li&gt;
&lt;li&gt;コンポーネントのメタデータで&lt;code&gt;styles&lt;/code&gt;か&lt;code&gt;styleUrls&lt;/code&gt;を使う方法&lt;/li&gt;
&lt;li&gt;CSS importsを使う方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これまでに説明したCSSのスコーピングは、どの方法でも適用されます。&lt;/p&gt;

&lt;h3 id=&#34;メタデータでスタイルを読み込む&#34;&gt;メタデータでスタイルを読み込む&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@Component&lt;/code&gt;デコレータの&lt;code&gt;styles&lt;/code&gt;プロパティで、stringの配列として記述できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;hero-app&#39;,
  template: `
    &amp;lt;h1&amp;gt;Tour of Heroes&amp;lt;/h1&amp;gt;
    &amp;lt;hero-app-main [hero]=hero&amp;gt;&amp;lt;/hero-app-main&amp;gt;`,
  styles: [&#39;h1 { font-weight: normal; }&#39;],
  directives: [HeroAppMainComponent]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;テンプレートインラインスタイル&#34;&gt;テンプレートインラインスタイル&lt;/h3&gt;

&lt;p&gt;テンプレートHTML中に&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;タグで直接埋め込むこともできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;hero-controls&#39;,
  template: `
    &amp;lt;style&amp;gt;
      button {
        background-color: white;
        border: 1px solid #777;
      }
    &amp;lt;/style&amp;gt;
    &amp;lt;h3&amp;gt;Controls&amp;lt;/h3&amp;gt;
    &amp;lt;button (click)=&amp;quot;activate()&amp;quot;&amp;gt;Activate&amp;lt;/button&amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;styleのurlをメタデータに記述する&#34;&gt;StyleのURLをメタデータに記述する&lt;/h3&gt;

&lt;p&gt;外部のCSSファイルを&lt;code&gt;styleUrls&lt;/code&gt;として記述することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;hero-details&#39;,
  template: `
    &amp;lt;h2&amp;gt;{{hero.name}}&amp;lt;/h2&amp;gt;
    &amp;lt;hero-team [hero]=hero&amp;gt;&amp;lt;/hero-team&amp;gt;
    &amp;lt;ng-content&amp;gt;&amp;lt;/ng-content&amp;gt;
  `,
  styleUrls: [&#39;app/hero-details.component.css&#39;],
  directives: [HeroTeamComponent]
})
export class HeroDetailsComponent {
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意-1&#34;&gt;注意&lt;/h4&gt;

&lt;p&gt;このURLは、&lt;code&gt;index.html&lt;/code&gt;から見た相対パスであり、コンポーネントのファイルから見た相対パスではありません。&lt;/p&gt;

&lt;h4 id=&#34;webpackの場合&#34;&gt;Webpackの場合&lt;/h4&gt;

&lt;p&gt;Webpackを使っている場合は、外部CSSを使いつつ&lt;code&gt;styles&lt;/code&gt;プロパティを使用することもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;styles: [require(&#39;my.component.css&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、バンドル時にCSSの読み込みが完了します。&lt;/p&gt;

&lt;h3 id=&#34;linkタグによる読み込み&#34;&gt;Linkタグによる読み込み&lt;/h3&gt;

&lt;p&gt;さらに、&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;タグでCSSファイルを読み込むこともできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;hero-team&#39;,
  template: `
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;app/hero-team.component.css&amp;quot;&amp;gt;
    &amp;lt;h3&amp;gt;Team&amp;lt;/h3&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li *ngFor=&amp;quot;#member of hero.team&amp;quot;&amp;gt;
        {{member}}
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;`
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、&lt;code&gt;styleUrls&lt;/code&gt;と同じように、アプリケーションのルートからの相対パスで記述します。&lt;/p&gt;

&lt;h3 id=&#34;css-importsによる読み込み&#34;&gt;CSS @importsによる読み込み&lt;/h3&gt;

&lt;p&gt;最後に、コンポーネントスタイルではCSS標準の&lt;a href=&#34;https://developer.mozilla.org/en/docs/Web/CSS/@import&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;@import&lt;/code&gt;ルール&lt;/a&gt;を使うこともできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@import &#39;hero-details-box.css&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ビューのカプセル化をコントロールする-native-emulated-none&#34;&gt;ビューのカプセル化をコントロールする： Native, Emulated, None&lt;/h2&gt;

&lt;p&gt;ここまでに述べたように、コンポーネントのCSSスタイルはカプセル化されています。
Angular 2では、コンポーネントごとに、スタイルのカプセル化の設定を行うことができます。現在は3つの選択肢があります&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Native&lt;/code&gt;：カプセル化にブラウザのネイティブ実装の&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM&#34; target=&#34;_blank&#34;&gt;Shadow DOM&lt;/a&gt;を使います。
コンポーネントのテンプレートHTMLは、Shadow DOM内に描画されます。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Emulated&lt;/code&gt;：(デフォルト)Shadow DOMの振る舞いをエミュレートし、描画後の要素に適切なクラスや属性を自動で付与して擬似的にカプセル化します。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;None&lt;/code&gt;：Angularによるカプセル化を行いません。
これまでに述べたスコーピングは適用されず、グローバルなスタイルが直接影響します。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらはコンポーネントのメタデータにある&lt;code&gt;encapsulation&lt;/code&gt;プロパティにセットします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// warning: few browsers support shadow DOM encapsulation at this time
encapsulation: ViewEncapsulation.Native
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Native&lt;/code&gt;はブラウザがShadow DOMを実装している時だけ動作します。
Shadow DOMはまだサポートが進んでいないため、多くの場合ではデフォルトの&lt;code&gt;Emulated&lt;/code&gt;を使うことをおすすめします。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular 2のローカル変数とexportAs</title>
      <link>http://blog.lacolaco.net/post/local-variables-and-exportas-of-angular-2/</link>
      <pubDate>Mon, 11 Apr 2016 00:41:39 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/local-variables-and-exportas-of-angular-2/</guid>
      <description>

&lt;p&gt;Angular 2には&lt;strong&gt;local variables&lt;/strong&gt;(ローカル変数)という機能があります。
公式のチュートリアルやデベロッパーガイドを読んでいると突然登場してみなさんを惑わしているかもしれません。
しかし、この機能はAngular 2を使いこなす上でとても重要なものなので、ぜひ知っておきましょう。&lt;/p&gt;

&lt;h2 id=&#34;ローカル変数と-シンタックス&#34;&gt;ローカル変数と&lt;code&gt;#&lt;/code&gt;シンタックス&lt;/h2&gt;

&lt;p&gt;ローカル変数とは、コンポーネントのテンプレート中で定義して使用できる変数のことです。
ローカル変数には原則として、ローカル変数を定義した要素のインスタンスが代入されます。
ローカル変数の定義は&lt;code&gt;#&lt;/code&gt;シンタックスを使います。&lt;/p&gt;

&lt;p&gt;次の例では、&lt;code&gt;input&lt;/code&gt;要素をローカル変数&lt;code&gt;i&lt;/code&gt;として定義し、
ボタンをクリックするときに&lt;code&gt;input&lt;/code&gt;要素の値をコンポーネントに渡しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;input type=&amp;quot;text&amp;quot; #i&amp;gt;
    &amp;lt;button (click)=&amp;quot;submit(i.value)&amp;quot;&amp;gt;submit&amp;lt;/button&amp;gt;
    &amp;lt;p&amp;gt;
      {{ value }}
    &amp;lt;/p&amp;gt;
  `
})
export class App {
  value: string;
  
  submit(value: string) {
    this.value = value;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでローカル変数&lt;code&gt;i&lt;/code&gt;は&lt;code&gt;HTMLInputElement&lt;/code&gt;のインスタンスになっています。
ローカル変数を使うと、データバインディングを行うことなく、要素が持つプロパティや属性を直接使うことができます。&lt;/p&gt;

&lt;h3 id=&#34;var-シンタックス&#34;&gt;&lt;code&gt;var-*&lt;/code&gt;シンタックス&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;#&lt;/code&gt;シンタックスは簡単に書けて便利ですが、通常だと&lt;code&gt;#&lt;/code&gt;記号はHTMLの中で使うことができないため、
Angular以外の何らかのツールを使おうとするとエラーを引き起こすことがあります。
そこで正常なHTMLとしての体裁を守ったままローカル変数を定義する方法として、&lt;code&gt;var-*&lt;/code&gt;シンタックスも用意されています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var-*&lt;/code&gt;シンタックスを使って先程のテンプレートを書き直すと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;input type=&amp;quot;text&amp;quot; var-i&amp;gt;
    &amp;lt;button (click)=&amp;quot;submit(i.value)&amp;quot;&amp;gt;submit&amp;lt;/button&amp;gt;
    &amp;lt;p&amp;gt;
      {{ value }}
    &amp;lt;/p&amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ローカル変数とフォーム&#34;&gt;ローカル変数とフォーム&lt;/h2&gt;

&lt;p&gt;Angular 2のローカル変数は、HTML要素のインスタンスを簡単に得ることができるので、
&lt;code&gt;form&lt;/code&gt;要素や&lt;code&gt;video&lt;/code&gt;要素といった、メソッドを持つ複雑な要素と併用することでとても便利になります。
公式のチートシートには&lt;code&gt;video&lt;/code&gt;要素をローカル変数に代入して&lt;code&gt;play()&lt;/code&gt;メソッドを使っている例が紹介されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;video #movieplayer ...&amp;gt;
  &amp;lt;button (click)=&amp;quot;movieplayer.play()&amp;quot;&amp;gt;
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じように&lt;code&gt;form&lt;/code&gt;要素をローカル変数に代入して便利に使ってみましょう！
次の例では&lt;code&gt;form&lt;/code&gt;要素をローカル変数&lt;code&gt;f&lt;/code&gt;に代入し、ボタンのクリックイベントで&lt;code&gt;reset()&lt;/code&gt;メソッドを呼び出しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;form #f&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;
      &amp;lt;button (click)=&amp;quot;f.reset()&amp;quot;&amp;gt;reset&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  `
})
export class App {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一切スクリプトを書かずにフォームのリセットが実装できました！
初めは見慣れない&lt;code&gt;#&lt;/code&gt;記号に戸惑うかもしれませんが、実はとても簡単で便利なものだということがわかってきましたか？&lt;/p&gt;

&lt;h2 id=&#34;exportas-属性&#34;&gt;&lt;code&gt;exportAs&lt;/code&gt;属性&lt;/h2&gt;

&lt;p&gt;ここまでのローカル変数は定義された要素のインスタンスを引き出すだけでしたが、
ローカル変数は&lt;code&gt;exportAs&lt;/code&gt;という機能によってさらに強力な機能になります。さっそく見ていきましょう！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exportAs&lt;/code&gt;属性はディレクティブのメタデータの1つで、
ローカル変数にHTML要素ではなくディレクティブのインスタンスを代入させたいときに使います。
Angular 2に組み込まれている&lt;code&gt;ngForm&lt;/code&gt;ディレクティブは&lt;code&gt;exportAs&lt;/code&gt;を活用しているいいサンプルです。
&lt;code&gt;ngForm&lt;/code&gt;ディレクティブのセレクタは&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;に一致するようになっていて、
HTML標準の&lt;code&gt;form&lt;/code&gt;要素が自動的に&lt;code&gt;ngForm&lt;/code&gt;ディレクティブで拡張されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({
  selector: &#39;form:not([ngNoForm]):not([ngFormModel]),ngForm,[ngForm]&#39;,
  bindings: [formDirectiveProvider],
  host: {
    &#39;(submit)&#39;: &#39;onSubmit()&#39;,
  },
  outputs: [&#39;ngSubmit&#39;],
  exportAs: &#39;ngForm&#39;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/angular/angular/blob/master/modules%2Fangular2%2Fsrc%2Fcommon%2Fforms%2Fdirectives%2Fng_form.ts#L80-L88&#34; target=&#34;_blank&#34;&gt;angular/ng_form.ts at master · angular/angular&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここで、&lt;code&gt;exportAs: &#39;ngForm&#39;&lt;/code&gt;というメタデータの設定に注目してください。
&lt;code&gt;ngForm&lt;/code&gt;は&lt;code&gt;form&lt;/code&gt;要素に一致しますが、ただ&lt;code&gt;&amp;lt;form #f&amp;gt;&lt;/code&gt;のようにローカル変数を定義しても代入されるのは&lt;code&gt;HTMLFormElement&lt;/code&gt;のインスタンスだけです。
&lt;code&gt;form&lt;/code&gt;要素に隠れている&lt;code&gt;ngForm&lt;/code&gt;ディレクティブのインスタンスを得るには、&lt;code&gt;&amp;lt;form #f=&amp;quot;ngForm&amp;quot;&amp;gt;&lt;/code&gt;という定義を行います。
つまり、&lt;code&gt;exportAs&lt;/code&gt;で指定された名前をキーに、ディレクティブのインスタンスを得ることができるのです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngForm&lt;/code&gt;のインスタンスを使うと、フォームの操作がとても簡単になります。次の例ではフォームに入力された値をJSONオブジェクトとして取り出して表示しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;form #f #ngf=&amp;quot;ngForm&amp;quot; (ngSubmit)=&amp;quot;submit(ngf.value)&amp;quot;&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;name&amp;quot;&amp;gt;
      
      &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;submit&amp;lt;/button&amp;gt;
      &amp;lt;button (click)=&amp;quot;f.reset()&amp;quot;&amp;gt;reset&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;p&amp;gt;{{ value | json }}&amp;lt;/p&amp;gt;
  `,
  directives: []
})
export class App {
  value: any;
  
  submit(value: any) {
    this.value = value;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカル変数&lt;code&gt;f&lt;/code&gt;は何も値を与えていないので、&lt;code&gt;form&lt;/code&gt;要素のインスタンスになりますが、
ローカル変数&lt;code&gt;ngf&lt;/code&gt;は&lt;code&gt;ngForm&lt;/code&gt;をキーに&lt;code&gt;ngForm&lt;/code&gt;ディレクティブのインスタンスが代入されます。
&lt;code&gt;ngForm&lt;/code&gt;ディレクティブはフォーム全体の値をオブジェクトとして扱える&lt;code&gt;value&lt;/code&gt;プロパティを持っているので、
&lt;code&gt;ngSubmit&lt;/code&gt;イベントでコンポーネントに値を渡しています。&lt;/p&gt;

&lt;p&gt;このように、テンプレート中でディレクティブのメソッドやプロパティにアクセスできるのがローカル変数と&lt;code&gt;exportAs&lt;/code&gt;の力です。&lt;/p&gt;

&lt;h2 id=&#34;exportas-を使ってみよう&#34;&gt;&lt;code&gt;exportAs&lt;/code&gt;を使ってみよう&lt;/h2&gt;

&lt;p&gt;もちろん自分で作るディレクティブにも&lt;code&gt;exportAs&lt;/code&gt;を使うことができます。
最後に自作ディレクティブをローカル変数として扱う例を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MyDiv&lt;/code&gt;ディレクティブは、&lt;code&gt;div&lt;/code&gt;要素に一致するセレクタと、自身の&lt;code&gt;text-transform&lt;/code&gt;スタイルを切り替えるメソッドを持っています。
そしてインスタンスを&lt;code&gt;myDiv&lt;/code&gt;として公開しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({
  selector: &amp;quot;div&amp;quot;,
  exportAs: &amp;quot;myDiv&amp;quot;
})
class MyDiv {
  
  constructor(private element: ElementRef, private renderer: Renderer) {
  }
  
  toUpper() {
    return this.renderer.setElementStyle(this.element.nativeElement, &amp;quot;text-transform&amp;quot;, &amp;quot;uppercase&amp;quot;);
  }
  
  toLower() {
    return this.renderer.setElementStyle(this.element.nativeElement, &amp;quot;text-transform&amp;quot;, &amp;quot;lowercase&amp;quot;);
  }
  
  reset() {
    return this.renderer.setElementStyle(this.element.nativeElement, &amp;quot;text-transform&amp;quot;, &amp;quot;&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをコンポーネントから使うと、次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;div #d=&amp;quot;myDiv&amp;quot;&amp;gt;Angular 2&amp;lt;/div&amp;gt;
    &amp;lt;button (click)=&amp;quot;d.toUpper()&amp;quot;&amp;gt;toUpper&amp;lt;/button&amp;gt;
    &amp;lt;button (click)=&amp;quot;d.toLower()&amp;quot;&amp;gt;toLower&amp;lt;/button&amp;gt;
    &amp;lt;button (click)=&amp;quot;d.reset()&amp;quot;&amp;gt;Reset&amp;lt;/button&amp;gt;
  `,
  directives: [MyDiv]
})
export class App {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://plnkr.co/edit/xDSVImO4wbFYLGIqViFO?p=preview&#34; target=&#34;_blank&#34;&gt;こちら&lt;/a&gt; で実際に動くサンプルを見ることができます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Angular 2のローカル変数について基礎的な部分を紹介し、&lt;code&gt;exportAs&lt;/code&gt;を活用することで機能的なディレクティブを作れることがわかってもらえたと思います。
ローカル変数を使うとコンポーネントのコード量を減らし、テンプレート内で直感的にHTML要素やディレクティブのインスタンスを扱うことができます。
ぜひ活用してみてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular 2の*シンタックス</title>
      <link>http://blog.lacolaco.net/post/template-syntax-in-angular-2/</link>
      <pubDate>Mon, 11 Apr 2016 00:03:48 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/template-syntax-in-angular-2/</guid>
      <description>

&lt;p&gt;先日主催したイベントで「Angular 2の&lt;code&gt;*&lt;/code&gt;記号が何の意味があるのかわからなくて気持ち悪い」という声を聞き、意外に知られてないと思ったので一度きちんと書いておこうと思います。
みなさんのAngular 2への理解の手助けになれば幸いです。&lt;/p&gt;

&lt;h2 id=&#34;angular-2におけるディレクティブ&#34;&gt;Angular 2におけるディレクティブ&lt;/h2&gt;

&lt;p&gt;Angular 2は基本的にコンポーネント志向であり、アプリケーションはコンポーネントで組み立てます。ただし、Angular 1と同じようにHTML要素やコンポーネントを修飾するためにディレクティブを使うことができます。&lt;/p&gt;

&lt;p&gt;次の&lt;code&gt;myDirective&lt;/code&gt;ディレクティブは、付与した要素のスタイルを変更し、&lt;code&gt;color&lt;/code&gt;を&lt;code&gt;red&lt;/code&gt;にします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {Component, Directive, ElementRef, Renderer} from &#39;angular2/core&#39;

@Directive({
  selector: &amp;quot;[myDirective]&amp;quot;
})
class MyDirective {
  
  constructor(
    private el: ElementRef, 
    private renderer: Renderer
  ) {}
  
  ngOnInit() {
    this.renderer.setElementStyle(this.el.nativeElement, &amp;quot;color&amp;quot;, &amp;quot;red&amp;quot;);
  }
}

@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;div myDirective&amp;gt;Hello {{name}}&amp;lt;/div&amp;gt;
  `,
  directives: [MyDirective]
})
export class App {
  constructor() {
    this.name = &#39;Angular2&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクティブにもコンポーネントと同じようにライフサイクルのメソッドフックが存在します。コンストラクタのDIで得たインスタンスを&lt;code&gt;ngOnInit&lt;/code&gt;で使用しています。&lt;/p&gt;

&lt;p&gt;また、ディレクティブの&lt;code&gt;selector&lt;/code&gt;メタデータは&lt;code&gt;myDirective&lt;/code&gt;要素でも&lt;code&gt;[myDirective]&lt;/code&gt;属性でも、もちろん&lt;code&gt;.myDirective&lt;/code&gt;クラスでもかまいません。(あまり知られていませんしオススメもしませんが、実はコンポーネントの&lt;code&gt;selector&lt;/code&gt;も要素である必要はありません。)&lt;/p&gt;

&lt;h2 id=&#34;シンタックス-テンプレート化&#34;&gt;&lt;code&gt;*&lt;/code&gt;シンタックス：テンプレート化&lt;/h2&gt;

&lt;p&gt;ディレクティブの基本的なことをおさらいした上で、&lt;code&gt;*&lt;/code&gt;記号について解説します。まずは上述の&lt;code&gt;myDirective&lt;/code&gt;ディレクティブが実際にどのようなDOMを生成しているかを確認しましょう。Chromeの開発者ツールでみると、次のような構成になっています。&lt;code&gt;my-app&lt;/code&gt;要素の中にテンプレートが展開され、その中で&lt;code&gt;mydirective&lt;/code&gt;属性が付与された&lt;code&gt;div&lt;/code&gt;要素にスタイルが適用されています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/20253/92d3ae19-886f-7b1b-5a1e-9d175a4e1cf0.png&#34; alt=&#34;Kobito.VDG9G4.png&#34; title=&#34;Kobito.VDG9G4.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;直感的だし、何も違和感のないDOM構造です。ここで、&lt;code&gt;myDirective&lt;/code&gt;ディレクティブに&lt;code&gt;*&lt;/code&gt;記号を付けて実行するとどうなるか見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;div *myDirective&amp;gt;Hello {{name}}&amp;lt;/div&amp;gt;
  `,
  directives: [MyDirective]
})
export class App {
  constructor() {
    this.name = &#39;Angular2&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/20253/59e3f444-d704-800d-0162-977c07daaa3a.png&#34; alt=&#34;Kobito.vS1Z2P.png&#34; title=&#34;Kobito.vS1Z2P.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;なんと、 &lt;code&gt;&amp;lt;!--template bindings={}--&amp;gt;&lt;/code&gt;という謎のコメントを残して&lt;code&gt;div&lt;/code&gt;要素が消えてしまいました！&lt;/p&gt;

&lt;h3 id=&#34;要素の-テンプレート化&#34;&gt;要素の「テンプレート化」&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;myDirective&lt;/code&gt;に&lt;code&gt;*&lt;/code&gt;プレフィックスをつけると&lt;code&gt;div&lt;/code&gt;要素が消えてしまいました。これは単に消えたのではなく、 &lt;strong&gt;「テンプレート化された」&lt;/strong&gt; のです。「テンプレート化」とは、要素をテンプレートとして保存し、いつでも複製できるようにする仕組みのことです。&lt;/p&gt;

&lt;p&gt;わかりやすい例として、&lt;code&gt;ngIf&lt;/code&gt;ディレクティブのソースコードを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({selector: &#39;[ngIf]&#39;, inputs: [&#39;ngIf&#39;]})
export class NgIf {
  private _prevCondition: boolean = null;

  constructor(private _viewContainer: ViewContainerRef, private _templateRef: TemplateRef) {}

  set ngIf(newCondition: any /* boolean */) {
    if (newCondition &amp;amp;&amp;amp; (isBlank(this._prevCondition) || !this._prevCondition)) {
      this._prevCondition = true;
      this._viewContainer.createEmbeddedView(this._templateRef);
    } else if (!newCondition &amp;amp;&amp;amp; (isBlank(this._prevCondition) || this._prevCondition)) {
      this._prevCondition = false;
      this._viewContainer.clear();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/angular/angular/blob/master/modules/angular2/src/common/directives/ng_if.ts#L26-L41&#34; target=&#34;_blank&#34;&gt;angular/ng_if.ts at master · angular/angular&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngIf&lt;/code&gt;ディレクティブは、&lt;code&gt;ngIf&lt;/code&gt;に与えられた値&lt;code&gt;newCondition&lt;/code&gt;をもとに、要素を生成したり、削除したりします。この「生成」を行うためにテンプレートが必要なのです。つまり、&lt;code&gt;*ngIf&lt;/code&gt;が付与された要素をテンプレートとして&lt;code&gt;ngIf&lt;/code&gt;ディレクティブが保持していて、そのテンプレートをもとに新しい要素を複製して表示しています。
これと同じ仕組みで&lt;code&gt;*ngFor&lt;/code&gt;も動作しています。&lt;code&gt;ngFor&lt;/code&gt;ディレクティブの場合は生成する数が複数になるだけで、本質的には&lt;code&gt;ngIf&lt;/code&gt;と何も変わりません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*ngIf&lt;/code&gt;や&lt;code&gt;*ngFor&lt;/code&gt;のように、そのディレクティブが付与された要素そのものをテンプレートとして用いるときに、&lt;code&gt;*&lt;/code&gt;シンタックスによるテンプレート化が必要なのです。&lt;/p&gt;

&lt;h3 id=&#34;viewcontainerref-と-templateref&#34;&gt;&lt;code&gt;ViewContainerRef&lt;/code&gt;と&lt;code&gt;TemplateRef&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;先ほど&lt;code&gt;myDirective&lt;/code&gt;要素に&lt;code&gt;*&lt;/code&gt;プレフィックスをつけた際に要素が消えてしまったのは、テンプレート化しただけでそのテンプレートを元に要素を作っていなかったからです。&lt;code&gt;myDirective&lt;/code&gt;でもテンプレートを使えるようにしてみましょう！&lt;/p&gt;

&lt;p&gt;テンプレート化された要素は&lt;code&gt;TemplateRef&lt;/code&gt;というクラスのインスタンスとしてDIできます。&lt;code&gt;TemplateRef&lt;/code&gt;は&lt;code&gt;*&lt;/code&gt;プレフィックスが付けられていないとDIできないので、基本的にはディレクティブは&lt;code&gt;TemplateRef&lt;/code&gt;を使用するか、しないかのどちらかを決める必要があります。(※オプショナルなDIを使って切り替えることも可能)&lt;/p&gt;

&lt;p&gt;テンプレートだけでは要素は生成できないので、テンプレートを元に要素を作ってくれるものもDIする必要があります。それが&lt;code&gt;ViewContainerRef&lt;/code&gt;です。&lt;code&gt;ViewContainerRef&lt;/code&gt;はディレクティブが付与された要素「があった場所」をコンテナとして使うためのクラスです。&lt;code&gt;ViewContainerRef&lt;/code&gt;と&lt;code&gt;TemplateRef&lt;/code&gt;を使うことで、コンテナの中にテンプレートから生成された要素を配置することができます。&lt;/p&gt;

&lt;p&gt;次の例では&lt;code&gt;myDirective&lt;/code&gt;ディレクティブを使って、同じ要素を2個生成するようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {Component, Directive, ViewContainerRef, TemplateRef} from &#39;angular2/core&#39;

@Directive({
  selector: &amp;quot;[myDirective]&amp;quot;
})
class MyDirective {
  
  constructor(
    private _template: TemplateRef,
    private _viewContainer: ViewContainerRef
  ) {}
  
  ngOnInit() {
    for(let i = 0; i &amp;lt; 2; i++) {
      this._viewContainer.createEmbeddedView(this._template);
    }
  }
}

@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;div *myDirective&amp;gt;Hello {{name}}&amp;lt;/div&amp;gt;
  `,
  directives: [MyDirective]
})
export class App {
  constructor() {
    this.name = &#39;Angular2&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ViewContainerRef&lt;/code&gt;クラスの&lt;code&gt;createEmbeddedView&lt;/code&gt;メソッドに&lt;code&gt;TemplateRef&lt;/code&gt;のインスタンスを渡すと、そのテンプレートを元に要素を生成し、コンテナに埋め込んでくれます。上記コードで生成されるDOMは次のようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/20253/99459f2b-907a-678f-b2ef-3c4846579283.png&#34; alt=&#34;Kobito.Fi9CZD.png&#34; title=&#34;Kobito.Fi9CZD.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ご覧のとおり、&lt;code&gt;my-app&lt;/code&gt;のテンプレートHTMLとはまったく違う構造になっています。テンプレート化を用いたディレクティブはコンポーネント側で定義したDOM構造を容易に破壊できてしまいます。なので明示的に&lt;code&gt;*&lt;/code&gt;シンタックスを使わないかぎり&lt;code&gt;TemplateRef&lt;/code&gt;は得られないようになっているのです。&lt;/p&gt;

&lt;h3 id=&#34;template-を使う方法&#34;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;を使う方法&lt;/h3&gt;

&lt;p&gt;余談ですが、&lt;code&gt;*&lt;/code&gt;シンタックスは&lt;code&gt;template&lt;/code&gt;要素で置き換えることができます。つまり、&lt;code&gt;template&lt;/code&gt;要素によってテンプレート化が可能だということです。&lt;/p&gt;

&lt;p&gt;先程の&lt;code&gt;*myDirective&lt;/code&gt;を使った例は&lt;code&gt;template&lt;/code&gt;要素を使うと次のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;my-app&#39;,
  template: `
    &amp;lt;template myDirective&amp;gt;
      &amp;lt;div&amp;gt;Hello {{name}}&amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;
  `,
  directives: [MyDirective]
})
export class App {
  constructor() {
    this.name = &#39;Angular2&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;template&lt;/code&gt;要素に&lt;code&gt;*&lt;/code&gt;プレフィックスのない&lt;code&gt;myDirective&lt;/code&gt;を付与し、その中にテンプレート化したいHTMLを記述します。これで先ほどとまったく同じテンプレート化が可能です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Angular 2の&lt;code&gt;*&lt;/code&gt;シンタックスはHTML要素のテンプレート化のためのものであり、&lt;code&gt;*ngIf&lt;/code&gt;や&lt;code&gt;*ngFor&lt;/code&gt;などの組み込みのディレクティブだけではなく、独自に使うことができる便利な機能です。ただし使いこなすのは簡単ではないので、コンポーネントによるビューの組み立てを身につけた後に習得して欲しい中級者向けのテクニックです。&lt;/p&gt;

&lt;p&gt;今回のサンプルコードは &lt;a href=&#34;http://plnkr.co/edit/ylBGrQhdlOZ0SunPLid6?p=preview&#34; target=&#34;_blank&#34;&gt;Plunker&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[日本語訳] Angular 2 Change Detection Explained</title>
      <link>http://blog.lacolaco.net/post/translation-angular-2-change-detection-explained/</link>
      <pubDate>Sun, 10 Apr 2016 10:50:17 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/translation-angular-2-change-detection-explained/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Original: &lt;a href=&#34;http://blog.thoughtram.io//angular/2016/02/22/angular-2-change-detection-explained.html&#34; target=&#34;_blank&#34;&gt;Angular 2 Change Detection Explained&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Written by: &lt;a href=&#34;http://twitter.com/PascalPrecht&#34; target=&#34;_blank&#34;&gt;Pascal Precht&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Translated at: 2/23/2016&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://ng-nl.org&#34; target=&#34;_blank&#34;&gt;NG-NL&lt;/a&gt;はとても素晴らしかったです!
私はAngular 2のChange Detectionについての話ができて光栄でしたし、多くの参加者に気に入っていただけて大成功だったようです。
この記事では、どのようにAngularのChange Detectionが動作しているのか、どうすればそれを高速化できるのかについて誰でも読めるようにするため、
発表の内容を文章に書き起こしたいと思います。
もしこの話に興味を持ったなら、&lt;a href=&#34;http://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/&#34; target=&#34;_blank&#34;&gt;こちらのスライド&lt;/a&gt;
を見ることができますし、発表の録画も近いうちに公開されるのでそれを見ることもできるでしょう。&lt;/p&gt;

&lt;p&gt;それでは見ていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;change-detectionとは何なのか&#34;&gt;Change Detectionとは何なのか？&lt;/h2&gt;

&lt;p&gt;Change Detectionの基本的な役割は、プログラムの内部の状態を取得し、それを何らかの方法でユーザーインターフェースに可視化することです。
この状態はオブジェクトや配列、プリミティブなど、JavaScriptにおけるあらゆるデータ構造になりえます。&lt;/p&gt;

&lt;p&gt;状態はユーザーインターフェースの中でパラグラフやフォーム、リンク、ボタンとなるかもしれません。
具体的に言えば、それはWeb上でDOMとなります。
つまり、私たちは基本的にデータを入力として取得し、DOMを生成してユーザーに見せています。
このプロセスを私たちはレンダリングと呼んでいます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.lacolaco.net/img/angular-2-change-detection-explained/cd-4.png&#34; alt=&#34;cd-4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;しかし、レンダリングは実行時に変更が起きた時、トリッキーになります。
DOMが描画されてからしばらく経ったあとのことです。
私たちはどのようにして、モデルの変更と、更新しなければならないDOMの位置を知るのでしょうか？
DOMツリーへのアクセスは常にコストが高いので、更新する位置を探すだけではなく、なるべく小さなアクセスに留めたいですね。&lt;/p&gt;

&lt;p&gt;これには多くの異なった方法で取り組むことができます。
例えば、一つの方法は単純にHTTPのリクエストを送り、ページ全体を再描画することです。
別のアプローチはDOMの古い状態と新しい状態を比較して、違う部分だけを描画する方法で、
これはReactJSが仮想DOMを使って行っていることです。&lt;/p&gt;

&lt;p&gt;もしあなたが他のフレームワークがこの問題をどう解決しているかに興味を持っているなら、
私たちは&lt;a href=&#34;http://twitter.com/teropa&#34; target=&#34;_blank&#34;&gt;Tero&lt;/a&gt;が書いた素晴らしい記事 &lt;a href=&#34;http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html&#34; target=&#34;_blank&#34;&gt;Change and its detection in JavaScript frameworks&lt;/a&gt;
をおすすめします。
この記事ではAngular 2だけに注目していきます。&lt;/p&gt;

&lt;p&gt;基本的にChange Detectionのゴールは、データとその変更を常に投影することです。&lt;/p&gt;

&lt;h2 id=&#34;何が変更を引き起こすのか&#34;&gt;何が変更を引き起こすのか？&lt;/h2&gt;

&lt;p&gt;さて、私たちはChange Detectionとは何かについて知りましたが、不思議に思うかもしれません。
実際にはどんなときに変更が起こるのでしょうか？
その変更がビューを更新する必要があると、Angularはいつ知るのでしょうか？
さあ、次のコードを見てきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  template: `
    &amp;lt;h1&amp;gt;{{firstname}} {{lastname}}&amp;lt;/h1&amp;gt;
    &amp;lt;button (click)=&amp;quot;changeName()&amp;quot;&amp;gt;Change name&amp;lt;/button&amp;gt;
  `
})
class MyApp {
firstname:string = &#39;Pascal&#39;;
  lastname:string = &#39;Precht&#39;;

changeName() {
    this.firstname = &#39;Brad&#39;;
    this.lastname = &#39;Green&#39;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もしこれがあなたが見る初めてのAngular 2のコンポーネントであれば、
&lt;a href=&#34;http://blog.thoughtram.io/angular/2015/04/09/developing-a-tabs-component-in-angular-2.html&#34; target=&#34;_blank&#34;&gt;building a tabs component&lt;/a&gt;
を読んだほうがいいかもしれません。&lt;/p&gt;

&lt;p&gt;上のコンポーネントはシンプルに2つのプロパティを表示し、
テンプレート内のボタンがクリックされた時にそれらを変更するメソッドを提供しています。
ボタンがクリックされた瞬間、アプリケーションの状態が変更されます。
なぜならコンポーネントのプロパティを変更しているからです。
その瞬間が、私たちがビューを更新したい瞬間です。&lt;/p&gt;

&lt;p&gt;こちらも見てください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component()
class ContactsApp implements OnInit{
contacts:Contact[] = [];

constructor(private http: Http) {}

ngOnInit() {
    this.http.get(&#39;/contacts&#39;)
      .map(res =&amp;gt; res.json())
      .subscribe(contacts =&amp;gt; this.contacts = contacts);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコンポーネントはコンタクトのリストを持ち、初期化時にHTTPリクエストを処理しています。
リクエストが返ってきたらリストが更新されます。
ここで、もう一度アプリケーションの状態が変わっています。
私たちはここでビューを更新したいです。&lt;/p&gt;

&lt;p&gt;基本的に、アプリケーションの状態は次の3つの出来事で変わります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;イベント&lt;/strong&gt; - &lt;code&gt;click&lt;/code&gt;, &lt;code&gt;submit&lt;/code&gt;, &amp;hellip;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XHR&lt;/strong&gt; - サーバーからデータを取得する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;タイマー&lt;/strong&gt; - &lt;code&gt;setTimeout()&lt;/code&gt;, &lt;code&gt;setInterval()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらはすべて非同期的です。
ここから導かれる結論は、
非同期的な処理が行われた後にはいつでも、アプリケーションの状態が変わっている可能性があるということです。
これがAngularにビューを更新するように教えなければいけないタイミングです。&lt;/p&gt;

&lt;h2 id=&#34;誰がangularに伝えるのか&#34;&gt;誰がAngularに伝えるのか？&lt;/h2&gt;

&lt;p&gt;さあ、私たちは今、何がアプリケーションの状態を変えるのかを知りました。
しかしこの特定の瞬間にビューを更新するように、Angularに伝えているのは何なのでしょうか？&lt;/p&gt;

&lt;p&gt;Angularは私たちに標準のAPIを直接使わせてくれます。
AngularにDOMを更新するように伝えるために呼び出さないといけない割り込みのメソッドはありません。
これは魔法でしょうか？&lt;/p&gt;

&lt;p&gt;もしあなたが私たちの前回の記事を読んでいたら、
それが&lt;a href=&#34;http://blog.thoughtram.io/angular/2016/01/22/understanding-zones.html&#34; target=&#34;_blank&#34;&gt;Zones&lt;/a&gt;のおかげであることを知っているでしょう。
事実、Angularは&lt;a href=&#34;http://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html&#34; target=&#34;_blank&#34;&gt;Zones in Angular 2&lt;/a&gt;という記事で書いた
&lt;code&gt;NgZone&lt;/code&gt;と呼ばれる自身のZoneを備えています。ぜひこれも読んでください。&lt;/p&gt;

&lt;p&gt;要約すると、Angularのソースコードのどこかに&lt;code&gt;ApplicationRef&lt;/code&gt;と呼ばれるものがあり、
それが&lt;code&gt;NgZones&lt;/code&gt;の&lt;code&gt;onTurnDone&lt;/code&gt;イベントを受信しているということです。
このイベントが発火されるたびに、&lt;code&gt;AppicationRef&lt;/code&gt;が実際にChange Detectionを処理している&lt;code&gt;tick()&lt;/code&gt;関数を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// very simplified version of actual source
class ApplicationRef {

  changeDetectorRefs:ChangeDetectorRef[] = [];

  constructor(private zone: NgZone) {
    this.zone.onTurnDone
      .subscribe(() =&amp;gt; this.zone.run(() =&amp;gt; this.tick());
  }

  tick() {
    this.changeDetectorRefs
      .forEach((ref) =&amp;gt; ref.detectChanges());
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;change-detection&#34;&gt;Change Detection&lt;/h2&gt;

&lt;p&gt;OK、いいですね、私たちはChange Detectionがいつ実行されるのかを知りました。
ですが、どのように処理されるのでしょうか？
ええ、Angular2において、まず私たちが知る必要があることは、
&lt;strong&gt;それぞれのコンポーネントがそれぞれのChange Detectorを持っている&lt;/strong&gt; ということです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.lacolaco.net/img/angular-2-change-detection-explained/cd-tree-2.png&#34; alt=&#34;cd-tree-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これは重大な事実です、なぜならそれぞれのコンポーネントについて個別に、
いつどのようにChange Detectionを処理するかをコントロールできるようにしてくれるからです。
詳しくは後で話します。&lt;/p&gt;

&lt;p&gt;私たちのコンポーネントツリーのどこかでイベントが起きた、例えばボタンがクリックされたと仮定しましょう。
次に何が起きるでしょうか？
私たちはちょうどZoneが与えられたハンドラーを実行し、
ターンが終了した時にAngularに伝え、
それが最終的にはAngularにChange Detectionを処理させることを学びました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.lacolaco.net/img/angular-2-change-detection-explained/cd-tree-7.png&#34; alt=&#34;cd-tree-7&#34; /&gt;&lt;/p&gt;

&lt;p&gt;それぞれのコンポーネントが自身のChange Detectorを持っていて、
しかもAngularアプリケーションはコンポーネントツリーで構成されているので、
当然の結果として私たちは &lt;strong&gt;Change Detectorツリー&lt;/strong&gt; も持っています。
このツリーはデータが常に上から下に流れている有向グラフとしてみることもできます。&lt;/p&gt;

&lt;p&gt;なぜデータが上から下に流れるのか、
それはルートコンポーネントから始まったChange Detectionが、
毎回ひとつひとつコンポーネントごとに上から下へ処理されるからです。
一方向のデータフローはサイクルよりも予測しやすいので素晴らしいです。
私たちは常にビューの中で使われているデータがどこから来たのかを知っています。
なぜならそれはそのコンポーネントの中からしか来ないからです。&lt;/p&gt;

&lt;p&gt;もう一つの興味深い観察点は、Change Detectionは一度通過した後は安定になるということです。
これは、もしコンポーネントのうちのひとつが
Change Detectionが処理されている間に何らかの副作用を追加で引き起こした時には
Angularがエラーを起こす、ということを意味します。&lt;/p&gt;

&lt;h2 id=&#34;高速化&#34;&gt;高速化&lt;/h2&gt;

&lt;p&gt;デフォルトでは、もし私たちがすべてのコンポーネントをイベントのたびに毎回チェックする必要があったとしても、
Angularはとても速いです。
Angularは数百万個のチェックを数msで実行できます。
これは主に、&lt;strong&gt;AngularがVMフレンドリーなコードを生成している&lt;/strong&gt; という事実に起因します。&lt;/p&gt;

&lt;p&gt;これはどういう意味でしょうか？
そうですね、私たちはそれぞれのコンポーネントが自身のChange Detectorを持っていると言いました。
それはそれぞれの個別のコンポーネントのChange Detectionを世話するための
単一の一般的なものがAngularにあるということではありません。&lt;/p&gt;

&lt;p&gt;なぜならどんなモデル構造であってもすべてのコンポーネントをチェックできるためには、
Change Detectorはダイナミックに書かれなければならないからです。
このような種類のコードは最適化できないため、VMは好みません。
オブジェクトの形は常に同じではないため、これは &lt;strong&gt;ポリモーフィック&lt;/strong&gt; と考えられます。&lt;/p&gt;

&lt;p&gt;それぞれのコンポーネントごとに、&lt;strong&gt;Angularは実行時にChange Detectorのクラスを生成します&lt;/strong&gt;。
それらはそのコンポーネントの形を絶対知っているため、モノモーフィックです。
VMはこのコードを完全に最適化可能で、とても高速に実行できます。
これの良い所は、Angularが自動的にやってくれるので私たちがこのことについて考慮する必要がないことです。&lt;/p&gt;

&lt;p&gt;このことについてさらに深い説明が欲しければ、&lt;a href=&#34;http://twitter.com/victorsavkin&#34; target=&#34;_blank&#34;&gt;Victor Savkin&lt;/a&gt;の
&lt;a href=&#34;https://www.youtube.com/watch?v=jvKGQSFQf10&#34; target=&#34;_blank&#34;&gt;Change Detection Reinvented&lt;/a&gt;をチェックしてください。&lt;/p&gt;

&lt;h2 id=&#34;スマートなchange-detection&#34;&gt;スマートなChange Detection&lt;/h2&gt;

&lt;p&gt;繰り返しますが、Angularはすべてのコンポーネントをイベントが起こるたびに毎回チェックする必要があります。
なぜなら…そう、アプリケーションの状態が変わっているかもしれないからです。
しかし、もしアプリケーションの状態が変わっていないとわかっている時、
アプリケーションの一部についてChange Detectionを実行&lt;strong&gt;しない&lt;/strong&gt;ようにAngularに教えられたら
すばらしいと思いませんか？&lt;/p&gt;

&lt;p&gt;そうです、その通り、それは可能です！
そこには、変更の有無を保証してくれるデータ構造、
&lt;strong&gt;Immutables&lt;/strong&gt;と&lt;strong&gt;Observables&lt;/strong&gt;があることがわかります。
これらの構造や型を使い、それをAngularに教えれば、
Change Detectionはもっともっと速くなります。
かっこいいですね。でもどうやるんでしょうか？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可変性を理解する&lt;/strong&gt;
例えばイミュータブルなデータ構造がなぜ、どのように、手助けできるのかを理解するために、
私たちは可変性が意味することを理解しなければなりません。
次のようなコンポーネントがあると仮定しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  template: &#39;&amp;lt;v-card [vData]=&amp;quot;vData&amp;quot;&amp;gt;&amp;lt;/v-card&amp;gt;&#39;
})
class VCardApp {

  constructor() {
    this.vData = {
      name: &#39;Christoph Burgdorf&#39;,
      email: &#39;christoph@thoughtram.io&#39;
    }
  }

  changeData() {
    this.vData.name = &#39;Pascal Precht&#39;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;VCardApp&lt;/code&gt;は&lt;code&gt;&amp;lt;v-code&amp;gt;&lt;/code&gt;を子コンポーネントとして使い、それは&lt;code&gt;vData&lt;/code&gt;というInputプロパティを持っています。
私たちは&lt;code&gt;VCardApp&lt;/code&gt;が持っている自身の&lt;code&gt;vData&lt;/code&gt;を使ってそのコンポーネントにデータを渡しています。
&lt;code&gt;vCard&lt;/code&gt;は２つのプロパティと、&lt;code&gt;vData&lt;/code&gt;の名前を返すメソッド&lt;code&gt;changeData()&lt;/code&gt;を持っています。
ここには何のマジックもありません。&lt;/p&gt;

&lt;p&gt;重要な部分は、&lt;code&gt;changeData()&lt;/code&gt;が&lt;code&gt;vData&lt;/code&gt;を&lt;code&gt;name&lt;/code&gt;プロパティを変更することで変化させていることです。
たとえそのプロパティが変わっても、&lt;code&gt;vData&lt;/code&gt;の参照は同じままです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;changeData()&lt;/code&gt;を実行するなんらかのイベントが発生したと仮定すると、
Change Detectionが実行されたとき何が起こるでしょうか？
最初に、&lt;code&gt;vData.name&lt;/code&gt;が変更され、それが&lt;code&gt;&amp;lt;v-card&amp;gt;&lt;/code&gt;に渡ります。
その時&lt;code&gt;&amp;lt;v-card&amp;gt;&lt;/code&gt;のChange Detectorは与えられた&lt;code&gt;vData&lt;/code&gt;がまだ以前と同じかどうかをチェックし、同じになります。
参照は変わっていませんが、しかし、&lt;code&gt;name&lt;/code&gt;プロパティは変わっているので、
AngularはChange Detectionをそのオブジェクトのために実行します。&lt;/p&gt;

&lt;p&gt;デフォルトではJavaScriptにおいてオブジェクトは可変(プリミティブを除いて)であるため、
Angularは保守的にならざるを得ず、
イベントが起こると毎回すべてのコンポーネントでChande Detectionを走らせなければなりません。&lt;/p&gt;

&lt;p&gt;ここでイミュータブルなデータ構造の出番です。&lt;/p&gt;

&lt;h2 id=&#34;不変オブジェクト&#34;&gt;不変オブジェクト&lt;/h2&gt;

&lt;p&gt;イミュータブルなオブジェクトは変化しないという保証を私たちに与えてくれます。
それは、もし私たちがイミュータブルなオブジェクトを使い、それを変更したければ、
必ず新しい参照が得られ、もとのオブジェクトは不変であるということを意味します。&lt;/p&gt;

&lt;p&gt;この擬似コードで見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;var vData = someAPIForImmutables.create({
              name: &#39;Pascal Precht&#39;
            });

var vData2 = vData.set(&#39;name&#39;, &#39;Christoph Burgdorf&#39;);

vData === vData2 // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;someAPIForImmutables&lt;/code&gt;はイミュータブルなデータ構造を使いたいときに使う任意のAPIです。
しかし、ご覧のとおり、私たちは簡単に&lt;code&gt;name&lt;/code&gt;プロパティを変更することができません。
特定の変更と共に新しいオブジェクトが得られ、新しい参照を持っています。
単純に言えば、&lt;strong&gt;変化があれば新しい参照を得る&lt;/strong&gt;ということです。&lt;/p&gt;

&lt;h2 id=&#34;チェックの回数を減らす&#34;&gt;チェックの回数を減らす&lt;/h2&gt;

&lt;p&gt;AngularはInputプロパティに変化がないときにサブツリーのChange Detectionをスキップできます。
私たちはこの「変化」が「新しい参照」を意味することを学びました。
もしイミュータブルなオブジェクトをAngularアプリケーションの中で使えば、
入力が変わっていないとき、
私たちがやるべきはAngularにコンポーネントがChange Detectionをスキップできることを教えることだけです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;v-card&amp;gt;&lt;/code&gt;を見てそれがどうやって動くのか見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  template: `
    &amp;lt;h2&amp;gt;{{vData.name}}&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;{{vData.email}}&amp;lt;/span&amp;gt;
  `
})
class VCardCmp {
  @Input() vData;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ご覧のとおり、&lt;code&gt;VCardCmp&lt;/code&gt;は自身のInputプロパティだけに依存しています。素晴らしいです。
私たちはAngularに、このようにChange Detectionの戦略を&lt;code&gt;OnPush&lt;/code&gt;にセットすることで、
自身のInputに変化がないときは子ツリーのChange Detectionをスキップしていいということを伝えられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  template: `
    &amp;lt;h2&amp;gt;{{vData.name}}&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;{{vData.email}}&amp;lt;/span&amp;gt;
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class VCardCmp {
  @Input() vData;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで終わりです！
大きなコンポーネントツリーをイメージしてください。
イミュータブルなオブジェクトが使われ、それがAngularに伝わったとき、私たちは
サブツリーすべてをスキップできます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.lacolaco.net/img/angular-2-change-detection-explained/cd-tree-8.png&#34; alt=&#34;cd-tree-8.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://twitter.com/jvandemo&#34; target=&#34;_blank&#34;&gt;Jurgen Van De Moere&lt;/a&gt;は
&lt;a href=&#34;http://www.jvandemo.com/how-i-optimized-minesweeper-using-angular-2-and-immutable-js-to-make-it-insanely-fast/&#34; target=&#34;_blank&#34;&gt;in-depth article&lt;/a&gt;で
彼がどのようにAngular 2とImmutable.jsを使って驚くほど高速なマインスイーパーを作ったのかを書いています。
ぜひチェックしてください。&lt;/p&gt;

&lt;h2 id=&#34;observables&#34;&gt;Observables&lt;/h2&gt;

&lt;p&gt;先に述べたように、Observablesも変化があったことを保証してくれます。
イミュータブルなオブジェクトと違い、
Observablesは変更があっても新しい参照は与えられません。
代わりに、変更に反応するために購読することができるイベントを発火してくれます。&lt;/p&gt;

&lt;p&gt;さて、Observablesを使い、サブツリーのChange Detectionをスキップするために&lt;code&gt;OnPush&lt;/code&gt;を使いたい場合、
オブジェクトの参照は絶対に変わらないのにどうするのでしょうか？
そのようなときに必要なもの、
つまり、コンポーネントツリーの中で特定のイベントをチェックするための経路を有効にする
&lt;strong&gt;とてもスマートな&lt;/strong&gt;方法をAngularが持っているということを明らかにします。&lt;/p&gt;

&lt;p&gt;それが意味するものを理解するために、、このコンポーネントを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  template: &#39;{{counter}}&#39;,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class CartBadgeCmp {

  @Input() addItemStream:Observable&amp;lt;any&amp;gt;;
  counter = 0;

  ngOnInit() {
    this.addItemStream.subscribe(() =&amp;gt; {
      this.counter++; // application state changed
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ショッピングカートがあるeコマースアプリケーションを作るとしましょう。
ユーザーが商品をショッピングカートに入れるたびに、
小さなカウンターをUI上に出し、
ユーザーがカートの中の商品の数を見られるようにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CartBadgeCmp&lt;/code&gt;はまさにそれをやっています。
&lt;code&gt;counter&lt;/code&gt;と、カートに商品が追加されるたびに発火されるイベントのStreamである、
Inputプロパティの&lt;code&gt;addItemStream&lt;/code&gt;を持っています。&lt;/p&gt;

&lt;p&gt;私たちはこの記事ではObservablesがどのように働くのか詳しくは触れません。
もしObservablesについて詳しく知りたいなら、
&lt;a href=&#34;http://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html&#34; target=&#34;_blank&#34;&gt;taking advantage of Observables in Angular 2&lt;/a&gt;
を読んでください。&lt;/p&gt;

&lt;p&gt;また、私たちはChange Detectionのストラテジーを&lt;code&gt;OnPush&lt;/code&gt;にセットし、
毎回ではなくコンポーネントのInputプロパティが変わったときだけChange Detectionが働くようにします。&lt;/p&gt;

&lt;p&gt;しかし、先述の通り&lt;code&gt;addItemStream&lt;/code&gt;の参照は変わることはなく、
このコンポーネントのサブツリーのChange Detectionは全く実行されません。
このコンポーネントは&lt;code&gt;ngOnInit&lt;/code&gt;ライフサイクルフックの中でストリームを購読し、
カウンターを加算しているので、これは問題です。
これはアプリケーションの状態の変化であり、
ビューに反映させたいと思いますよね？&lt;/p&gt;

&lt;p&gt;これが私たちの(&lt;strong&gt;すべて&lt;/strong&gt;を&lt;strong&gt;OnPush&lt;/strong&gt;に設定した)Change Detectorツリーの見え方です。
イベントが起きてもChange Detectionは全く動作しません。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.lacolaco.net/img/angular-2-change-detection-explained/cd-tree-10.png&#34; alt=&#34;cd-tree-10&#34; /&gt;&lt;/p&gt;

&lt;p&gt;どうすればAngularに変更を知らせることができるでしょうか？
どうすればたとえツリー全体が&lt;code&gt;OnPush&lt;/code&gt;にセットされていても、
このコンポーネントはChange Detectionの実行が&lt;strong&gt;必要&lt;/strong&gt;だとAngularに知らせることができるでしょうか？&lt;/p&gt;

&lt;p&gt;ご心配なく、Angularはちゃんとカバーしています。
先ほど学んだように、Change Detectionは&lt;strong&gt;常に&lt;/strong&gt;上から下に動作します。
そして私たちがやらないといけないのは、
変更が起きたコンポーネントまでのツリーの経路の変化を検知する方法です。
Angularはその経路がわかりませんが、私たちにはわかります。&lt;/p&gt;

&lt;p&gt;私たちは&lt;a href=&#34;http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html&#34; target=&#34;_blank&#34;&gt;dependency injection&lt;/a&gt;を通じて、
&lt;code&gt;markForCheck()&lt;/code&gt;というAPIを備えたコンポーネントの&lt;code&gt;ChangeDetectorRef&lt;/code&gt;にアクセスできます。
このメソッドがまさに私たちが求めているものです！
これは次のChange Detectionでチェックされるために、ルートからコンポーネントまでの経路をマークします。&lt;/p&gt;

&lt;p&gt;さあコンポーネントに注入してみましょう。&lt;/p&gt;

&lt;p&gt;Let’s inject it into our component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;constructor(private cd: ChangeDetectorRef) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、チェックされるためにこのコンポーネントからルートまでの経路をAngularに伝えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  ngOnInit() {
    this.addItemStream.subscribe(() =&amp;gt; {
      this.counter++; // application state changed
      this.cd.markForCheck(); // marks path
    })
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Boom,これだけです！
これはObservableのイベントが発火されたあと、Change Detectionが始まる前です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.lacolaco.net/img/angular-2-change-detection-explained/cd-tree-12.png&#34; alt=&#34;cd-tree-12&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そして、Change Detectionが実行されると、シンプルに上から下へと進んでいきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.lacolaco.net/img/angular-2-change-detection-explained/cd-tree-13.png&#34; alt=&#34;cd-tree-13&#34; /&gt;&lt;/p&gt;

&lt;p&gt;クールですよね？一度Change Detectionが走った後は、ツリー全体は&lt;code&gt;OnPush&lt;/code&gt;状態に戻ります。&lt;/p&gt;

&lt;h2 id=&#34;もっと詳しく&#34;&gt;もっと詳しく&lt;/h2&gt;

&lt;p&gt;実際にはこの記事ではカバーしきれないたくさんのAPIがありますが、
スライドや発表の録画を見るといいでしょう。&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://github.com/thoughtram/angular2-change-detection-demos&#34; target=&#34;_blank&#34;&gt;リポジトリ&lt;/a&gt;には
あなたのローカルマシンで試すためのいくつかのデモがあります。&lt;/p&gt;

&lt;p&gt;イミュータブルなデータ構造やObservableがどのようにAngularのアプリケーションを速くできるのかについて
もう少し明らかにしました。&lt;/p&gt;

&lt;h2 id=&#34;謝辞&#34;&gt;謝辞&lt;/h2&gt;

&lt;p&gt;この発表を準備するにあたって、&lt;strong&gt;多大な&lt;/strong&gt;助けと支援となった
&lt;a href=&#34;http://twitter.com/jvandemo&#34; target=&#34;_blank&#34;&gt;Jurgen Van De Moere&lt;/a&gt;に感謝したい。
彼は私の理解について議論するのに多くの時間を費やし、
このコンテンツに入っている私を助ける良い質問を沢山挙げてくれました。
また、彼はデモがよく動くように確認してくれました。
彼のCSSスキルは素晴らしいです。
Jurgen、そんな支えになるいい人であることにとてもとても感謝します。&lt;/p&gt;

&lt;p&gt;Angular 2のChange Detectionについての質問にたくさん答えてくれた
&lt;a href=&#34;http://twitter.com/victorsavkin&#34; target=&#34;_blank&#34;&gt;Victor Savkin&lt;/a&gt;と彼が書いた
とても参考になる記事に感謝したい。
ありがとうVictor！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[日本語訳] Template-driven Forms in Angular 2</title>
      <link>http://blog.lacolaco.net/post/translation-template-driven-form-in-angular-2/</link>
      <pubDate>Sun, 10 Apr 2016 10:29:17 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/translation-template-driven-form-in-angular-2/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Original: &lt;a href=&#34;http://blog.thoughtram.io/angular/2016/03/21/template-driven-forms-in-angular-2.html&#34; target=&#34;_blank&#34;&gt;Template-driven Forms in Angular 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Written by: &lt;a href=&#34;http://twitter.com/PascalPrecht&#34; target=&#34;_blank&#34;&gt;Pascal Precht&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Translated at: 04/07/2016&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;angular-2におけるテンプレート駆動フォーム&#34;&gt;Angular 2におけるテンプレート駆動フォーム&lt;/h1&gt;

&lt;p&gt;Angularはフォームを組み立てるのに3つの異なる方法を用意しています。
1つはテンプレート駆動、アプリケーションコードを一切必要としない方法です。
そしてローレベルAPIを使ったDOMを一切必要としないモデル駆動の方法と、
最後はハイレベルのAPI、すなわち&lt;code&gt;FormBuilder&lt;/code&gt;を使ったモデル駆動の方法です。&lt;/p&gt;

&lt;p&gt;これらの異なる手段からわかるように、目標を達成するための道具がいくつもあるかもしれないのは当然のことです。
しかし混乱を招いてしまうので、この記事ではAngular 2におけるテンプレート駆動のフォームディレクティブについて明らかにしていきます。&lt;/p&gt;

&lt;h2 id=&#34;ngform-ディレクティブ&#34;&gt;&lt;code&gt;ngForm&lt;/code&gt;ディレクティブ&lt;/h2&gt;

&lt;p&gt;まずはユーザーの情報をいくつか質問するシンプルなログインフォームからはじめましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form&amp;gt;
  &amp;lt;label&amp;gt;Firstname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Lastname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Street:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Zip:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;City:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;

  &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Submit&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私たちはおそらくこんなフォームを何度も作ったことがあります。
ユーザーの名前と住所を入力するコントロールを持ったシンプルなHTMLのフォームで、ここには何の特別なものはありません。&lt;/p&gt;

&lt;p&gt;私たちはここで、Angularが連れてきた&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;というセレクターを持つ&lt;code&gt;ngForm&lt;/code&gt;ディレクティブによって、
実は私たちの&lt;code&gt;form&lt;/code&gt;要素がすでに&lt;code&gt;ngForm&lt;/code&gt;のインスタンスになっているということに気づきません。
&lt;code&gt;ngForm&lt;/code&gt;はとある理由のために存在します。
&lt;code&gt;ngForm&lt;/code&gt;は私たちにフォームが持っている現在の状態を伝えてくれます。状態というのは次のものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;フォームの値のJSON表現&lt;/li&gt;
&lt;li&gt;フォーム全体のバリデーション状態&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ngform-インスタンスにアクセスする&#34;&gt;&lt;code&gt;ngForm&lt;/code&gt;インスタンスにアクセスする&lt;/h3&gt;

&lt;p&gt;ディレクティブのメタデータの&lt;code&gt;exportAs&lt;/code&gt;プロパティを使うと、コンポーネントのテンプレート内でディレクティブのインスタンスにアクセスできます。
例えば、&lt;code&gt;draggable&lt;/code&gt;ディレクティブを作ったとき、そのインスタンスを次のように&lt;code&gt;draggable&lt;/code&gt;という名前で外部に露出できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Directive({
  selector: &#39;[draggable]&#39;,
  exportAs: &#39;draggable&#39;
})
class Draggable {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、ディレクティブを使っているテンプレート内でローカル変数の仕組みを使ってアクセスすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;&amp;lt;div draggable #myDraggable=&amp;quot;draggable&amp;quot;&amp;gt;I&#39;m draggable!&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで&lt;code&gt;myDraggable&lt;/code&gt;は&lt;code&gt;Draggable&lt;/code&gt;のインスタンスの参照になっていて、
テンプレート全体で他の式の一部として使うことができます。&lt;/p&gt;

&lt;p&gt;これがどうして面白いのか不思議に思うかもしれません。
そう、&lt;code&gt;ngForm&lt;/code&gt;ディレクティブが&lt;code&gt;ngForm&lt;/code&gt;として露出されていること、
それは一切アプリケーションコードを書かずに次のようにフォームのインスタンスにアクセスできるということなのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form #form=&amp;quot;ngForm&amp;quot;&amp;gt;
  ...
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;フォームの送信と-値へのアクセス&#34;&gt;フォームの送信と、値へのアクセス&lt;/h3&gt;

&lt;p&gt;さあ私たちはフォームの値とそのバリデーション状態にアクセスできるようになりました。
まずはフォームから送信されたデータをログに表示してみましょう。
私たちがやらなければならないのは、フォームの&lt;code&gt;submit&lt;/code&gt;イベントにハンドラーを追加してフォームの値を渡すことだけです。
実は&lt;code&gt;ngForm&lt;/code&gt;のインスタンスには&lt;code&gt;value&lt;/code&gt;プロパティがあるので、次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form #form=&amp;quot;ngForm&amp;quot; (submit)=&amp;quot;logForm(form.value)&amp;quot;&amp;gt;
  ...
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでもうまく動きますが、&lt;code&gt;ngForm&lt;/code&gt;が送信時に発火しているもう一つのイベントがあります。それが&lt;code&gt;ngSubmit&lt;/code&gt;です。
&lt;code&gt;ngSubmit&lt;/code&gt;は&lt;code&gt;submit&lt;/code&gt;と一見すると全く同じです。
しかし、&lt;code&gt;ngSubmit&lt;/code&gt;はイベントハンドラーがエラーを出したときには(デフォルトの&lt;code&gt;form&lt;/code&gt;要素と同じように)&lt;code&gt;submit&lt;/code&gt;されないことと、
HTTPのPOSTリクエストを発生させることが保証されています。
ベストプラクティスとして、&lt;code&gt;submit&lt;/code&gt;の代わりに&lt;code&gt;ngSubmit&lt;/code&gt;を使ってみましょう！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form #form=&amp;quot;ngForm&amp;quot; (ngSubmit)=&amp;quot;logForm(form.value)&amp;quot;&amp;gt;
  ...
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、次のようなコンポーネントを用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;@Component({
  selector: &#39;app&#39;,
  template: ...
})
class App {

  logForm(value: any) {
    console.log(value);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを実行すると、フォームの値は空のオブジェクトなのがわかります。
これは正しい挙動です。なぜならまだコンポーネントのテンプレート中に何もしていないからです。
つまり、私たちはフォームにinput要素を登録しなければなりません。そこで&lt;code&gt;ngControl&lt;/code&gt;が登場します。&lt;/p&gt;

&lt;h2 id=&#34;ngcontrol-ディレクティブ&#34;&gt;&lt;code&gt;ngControl&lt;/code&gt;ディレクティブ&lt;/h2&gt;

&lt;p&gt;フォームのインスタンスにコントロールを登録するために、&lt;code&gt;ngControl&lt;/code&gt;ディレクティブを使います。&lt;code&gt;ngControl&lt;/code&gt;は文字列の名前を持ち、コントロールとしての抽象的なインスタンスを作成します。&lt;code&gt;ngControl&lt;/code&gt;で登録されたすべてのフォームコントロールは自動的に&lt;code&gt;form.value&lt;/code&gt;に現れ、簡単に処理できるようになります。&lt;/p&gt;

&lt;p&gt;いくつかのオブジェクトをフォームに追加し、フォームコントロールとして登録してみましょう！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form #form=&amp;quot;ngForm&amp;quot; (ngSubmit)=&amp;quot;logForm(form.value)&amp;quot;&amp;gt;
  &amp;lt;label&amp;gt;Firstname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;firstname&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Lastname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;lastname&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Street:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;street&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Zip:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;zip&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;City:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;city&amp;quot;&amp;gt;

  &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Submit&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ばっちりですね！このフォームに適当な値を入力して送信すれば、次のようなログが見られるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  firstname: &#39;Pascal&#39;,
  lastname: &#39;Precht&#39;,
  street: &#39;thoughtram Road&#39;,
  zip: &#39;00011&#39;,
  city: &#39;San Francisco&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;素晴らしいですね！
私たちはこのJSONオブジェクトを手に入れて、サーバーへ直接送信することができます。
しかしちょっと待ってください？もし次のようなもっと複雑な構造が欲しい時はどうすればいいんでしょうか？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  name: {
    firstname: &#39;Pascal&#39;,
    lastname: &#39;Precht&#39;,
  },
  address: {
    street: &#39;thoughtram Road&#39;,
    zip: &#39;00011&#39;,
    city: &#39;San Francisco&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フォームをsubmitした時に手で組み立てる必要があるのでしょうか？
答えはノーです！Angularはこれをちゃんとカバーしています。
というわけで、次は&lt;code&gt;ngControlGroup&lt;/code&gt;の紹介です。&lt;/p&gt;

&lt;h2 id=&#34;ngcontrolgroup-ディレクティブ&#34;&gt;&lt;code&gt;ngControlGroup&lt;/code&gt;ディレクティブ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ngControlGroup&lt;/code&gt;はフォームコントロールをグループ化することができます。
別の言い方をすれば、コントロールグループはコントロールなしには存在できません。
さらに、コントロールグループはその中にあるコントロールがvalidかどうかを引き継いでくれます。
これによって簡単にフォームの中でバリデーションチェックがとても簡単になります。&lt;/p&gt;

&lt;p&gt;ここであなたはこう考えるかもしれません。
「ちょっと待てよ？つまりフォーム自体が1つのコントロールグループなんじゃないか？」
そう、その通りです。フォームは1つのコントロールグループです。&lt;/p&gt;

&lt;p&gt;さっそく&lt;code&gt;ngControlGroup&lt;/code&gt;を使ってコントロールをグループ化してみましょう！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;fieldset ngControlGroup=&amp;quot;name&amp;quot;&amp;gt;
  &amp;lt;label&amp;gt;Firstname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;firstname&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Lastname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;lastname&amp;quot;&amp;gt;
&amp;lt;/fieldset&amp;gt;

&amp;lt;fieldset ngControlGroup=&amp;quot;address&amp;quot;&amp;gt;
  &amp;lt;label&amp;gt;Street:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;street&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;Zip:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;zip&amp;quot;&amp;gt;

  &amp;lt;label&amp;gt;City:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;city&amp;quot;&amp;gt;
&amp;lt;/fieldset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ご覧のとおり、上のコードでは私たちはフォームコントロールを&lt;code&gt;&amp;lt;fieldset&amp;gt;&lt;/code&gt;要素でラップし、
&lt;code&gt;ngControlGroup&lt;/code&gt;ディレクティブを適用しています。
これは特に意味があるわけではなく、代わりに&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;要素を使ってもかまいません。
ポイントは、何かしらの要素である必要があり、
そこに&lt;code&gt;ngControlGroup&lt;/code&gt;をつけることで&lt;code&gt;ngForm&lt;/code&gt;に対して登録されるということです。&lt;/p&gt;

&lt;p&gt;このフォームを送信すれば次のような出力が得られるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  name: {
    firstname: &#39;Pascal&#39;,
    lastname: &#39;Precht&#39;,
  },
  address: {
    street: &#39;thoughtram Road&#39;,
    zip: &#39;00011&#39;,
    city: &#39;San Francisco&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完璧ですね！
私たちは望む構造のオブジェクトを一切アプリケーションコードを書かずにフォームだけで構築できました。
しかし不思議に思うかもしれません。Angular 2でフォームの中で&lt;code&gt;ngModel&lt;/code&gt;を使うとどうなるんでしょうか。
これは良い質問です。&lt;/p&gt;

&lt;h2 id=&#34;ngmodel-とは&#34;&gt;&lt;code&gt;ngModel&lt;/code&gt;とは？&lt;/h2&gt;

&lt;p&gt;Angular 2における&lt;code&gt;ngModel&lt;/code&gt;は双方向データバインディングを実装しているものです。
ただしそれだけではなく、実はもっと多くのケースでシンプルに使えるものです。
テンプレート駆動のフォームに&lt;code&gt;ngModel&lt;/code&gt;をどう使えばいいのでしょうか？そもそも&lt;code&gt;ngModel&lt;/code&gt;を使えるのでしょうか？
もちろん使えます！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngForm&lt;/code&gt;や&lt;code&gt;ngControl&lt;/code&gt;、&lt;code&gt;ngControlGroup&lt;/code&gt;が提供するのはフォームの構造化と、フォームの値へのアクセスですが、
一方で&lt;code&gt;ngModel&lt;/code&gt;が提供するのは双方向データバインディングのためのドメインモデルです。
言い方を変えれば、&lt;code&gt;form.value&lt;/code&gt;はサーバーに送りたいデータであり、
&lt;code&gt;ngModel&lt;/code&gt;はフォームにデータを与えることができますが、これらは同時に使うことができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngControl&lt;/code&gt;は&lt;code&gt;ngModel&lt;/code&gt;がバインドできるようになっています。
つまり次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;fieldset ngControlGroup=&amp;quot;name&amp;quot;&amp;gt;
  &amp;lt;label&amp;gt;Firstname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;firstname&amp;quot; [(ngModel)]=&amp;quot;firstname&amp;quot;&amp;gt;
  &amp;lt;p&amp;gt;You entered {{firstname}}&amp;lt;/p&amp;gt;

  &amp;lt;label&amp;gt;Lastname:&amp;lt;/label&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; ngControl=&amp;quot;lastname&amp;quot; [(ngModel)]=&amp;quot;lastname&amp;quot;&amp;gt;
  &amp;lt;p&amp;gt;You entered {{lastname}}&amp;lt;/p&amp;gt;
&amp;lt;/fieldset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;もっと知りたい方は&#34;&gt;もっと知りたい方は&lt;/h2&gt;

&lt;p&gt;もちろんここで述べたのはフォームを作る方法の氷山の一角です。
バリデーションについてや、入力されたデータに対してエラーメッセージをどう表示するかなど、話していないことがたくさんあります。
それらについてはまた別の記事で紹介します。
ただしカスタムバリデーターを作る方法については&lt;a href=&#34;http://blog.thoughtram.io/angular/2016/03/14/custom-validators-in-angular-2.html&#34; target=&#34;_blank&#34;&gt;この記事&lt;/a&gt;を見てください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ViewEncapsulationのフォールバック</title>
      <link>http://blog.lacolaco.net/post/angular2-view-encapsulation-fallback/</link>
      <pubDate>Sun, 10 Apr 2016 00:23:58 +0900</pubDate>
      
      <guid>http://blog.lacolaco.net/post/angular2-view-encapsulation-fallback/</guid>
      <description>

&lt;p&gt;ブラウザがShadow DOMを実装している場合は&lt;code&gt;ViewEncapsulation.Native&lt;/code&gt;を、
そうでない場合はデフォルトの&lt;code&gt;ViewEncapsulation.Emulated&lt;/code&gt;を使うようにフォールバックを実装する方法。&lt;/p&gt;

&lt;h3 id=&#34;shadow-dom-check&#34;&gt;Shadow DOM Check&lt;/h3&gt;

&lt;p&gt;まずアプリケーション全体で統一の&lt;code&gt;ViewEncapsulation&lt;/code&gt;を使うためにコンフィグ用の&lt;code&gt;default-view-encapsulation.ts&lt;/code&gt;を用意します。
よくよく調べるとAngular2の&lt;code&gt;Native&lt;/code&gt;はShadow DOM v1ではないようだけど、
&lt;code&gt;BrowserDomAdapter&lt;/code&gt;経由で調べるのでAngular側がいつv1準拠になっても大丈夫にしてある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {ViewEncapsulation} from &amp;quot;angular2/core&amp;quot;;
import {BrowserDomAdapter} from &amp;quot;angular2/platform/browser&amp;quot;;

let domAdapter = new BrowserDomAdapter();

export var DEFAULT_VIEW_ENCAPSULATION = domAdapter.supportsNativeShadowDOM() ?
    ViewEncapsulation.Native : ViewEncapsulation.Emulated;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ChromeとSafariでしか見てないけどChromeのほうが若干初期ロードが速い気がする。
SharedStyleを使わない分JSでの処理が少ないだろうことは予想できる。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>